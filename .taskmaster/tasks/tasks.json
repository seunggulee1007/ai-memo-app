{
  "master": {
    "tasks": [
      {
        "id": 11,
        "title": "프로젝트 초기 설정 및 기본 구조 구축",
        "description": "Next.js 15와 React 19 기반의 프로젝트를 설정하고 기본 폴더 구조와 환경 설정을 완료합니다.",
        "details": "1. Next.js 15 프로젝트 생성: `npx create-next-app@latest ai-memo-app --typescript --tailwind --app`\n2. 필수 패키지 설치: React 19, TypeScript, Tailwind CSS, ESLint, Prettier\n3. 폴더 구조 설정:\n   - `/app`: App Router 기반 페이지 구조\n   - `/components`: 재사용 가능한 UI 컴포넌트\n   - `/lib`: 유틸리티 함수 및 헬퍼\n   - `/prisma`: 데이터베이스 스키마 및 클라이언트\n   - `/public`: 정적 파일\n4. 환경 변수 설정 (.env.local, .env.example)\n5. TypeScript 설정 (tsconfig.json)\n6. Tailwind CSS 설정 및 테마 구성 (다크모드 지원)\n7. ESLint 및 Prettier 설정\n8. Git 저장소 초기화 및 .gitignore 설정",
        "testStrategy": "1. 프로젝트 빌드 및 개발 서버 실행 테스트\n2. TypeScript 타입 체크 검증\n3. ESLint 및 Prettier 규칙 준수 확인\n4. 다크모드/라이트모드 전환 테스트\n5. 폴더 구조 및 파일 구성 검토",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "데이터베이스 설정 및 DrizzleORM 스키마 구현",
        "description": "Supabase 데이터베이스를 설정하고 DrizzleORM을 통해 PRD에 정의된 데이터 모델을 구현합니다.",
        "details": "1. PostgreSQL 데이터베이스 설정 (Supabase 또는 PlanetScale 활용)\n2. DrizzleORM 설치 및 초기화: `npm install prisma @prisma/client`\n3. Prisma 스키마 정의 (schema.prisma):\n```prisma\nmodel User {\n  id        String   @id @default(cuid())\n  email     String   @unique\n  name      String\n  avatar    String?\n  memos     Memo[]\n  tags      Tag[]\n  teams     TeamMember[]\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n\nmodel Memo {\n  id            String         @id @default(cuid())\n  title         String\n  content       String         @db.Text\n  userId        String\n  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)\n  isPublic      Boolean        @default(false)\n  tags          TagsOnMemos[]\n  aiSuggestions AISuggestion[]\n  teamId        String?\n  team          Team?          @relation(fields: [teamId], references: [id])\n  createdAt     DateTime       @default(now())\n  updatedAt     DateTime       @updatedAt\n}\n\nmodel Tag {\n  id        String        @id @default(cuid())\n  name      String\n  color     String\n  userId    String\n  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)\n  memos     TagsOnMemos[]\n  createdAt DateTime      @default(now())\n  updatedAt DateTime      @updatedAt\n}\n\nmodel TagsOnMemos {\n  memoId    String\n  memo      Memo     @relation(fields: [memoId], references: [id], onDelete: Cascade)\n  tagId     String\n  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)\n  createdAt DateTime @default(now())\n\n  @@id([memoId, tagId])\n}\n\nmodel AISuggestion {\n  id        String   @id @default(cuid())\n  memoId    String\n  memo      Memo     @relation(fields: [memoId], references: [id], onDelete: Cascade)\n  type      String\n  content   String   @db.Text\n  applied   Boolean  @default(false)\n  createdAt DateTime @default(now())\n}\n\nmodel Team {\n  id          String       @id @default(cuid())\n  name        String\n  description String?\n  members     TeamMember[]\n  memos       Memo[]\n  createdAt   DateTime     @default(now())\n  updatedAt   DateTime     @updatedAt\n}\n\nmodel TeamMember {\n  id       String   @id @default(cuid())\n  teamId   String\n  team     Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)\n  userId   String\n  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n  role     String\n  joinedAt DateTime @default(now())\n\n  @@unique([teamId, userId])\n}\n```\n4. 데이터베이스 마이그레이션 생성: `npx prisma migrate dev --name init`\n5. Prisma 클라이언트 생성 및 싱글톤 패턴 구현:\n```typescript\n// lib/prisma.ts\nimport { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient }\n\nexport const prisma = globalForPrisma.prisma || new PrismaClient()\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n```\n6. 전체 텍스트 검색을 위한 인덱스 설정",
        "testStrategy": "1. 데이터베이스 연결 테스트\n2. Prisma 마이그레이션 검증\n3. 모든 모델에 대한 CRUD 작업 테스트\n4. 관계 쿼리 테스트 (User-Memo, Memo-Tag 등)\n5. 인덱스 성능 테스트\n6. 트랜잭션 및 롤백 테스트",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "사용자 인증 시스템 구현",
        "description": "JWT 기반 인증 시스템을 구현하여 사용자 등록, 로그인, 로그아웃 및 프로필 관리 기능을 제공합니다.",
        "details": "1. NextAuth.js 설치 및 설정: `npm install next-auth@beta`\n2. 인증 API 라우트 구현:\n   - `/app/api/auth/[...nextauth]/route.ts`: NextAuth 핸들러\n   - `/app/api/auth/register/route.ts`: 회원가입 API\n3. JWT 전략 구성 및 세션 관리:\n```typescript\n// app/api/auth/[...nextauth]/route.ts\nimport NextAuth from 'next-auth'\nimport CredentialsProvider from 'next-auth/providers/credentials'\nimport { compare } from 'bcrypt'\nimport { prisma } from '@/lib/prisma'\n\nexport const authOptions = {\n  providers: [\n    CredentialsProvider({\n      name: 'Credentials',\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" }\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          return null\n        }\n\n        const user = await prisma.user.findUnique({\n          where: { email: credentials.email }\n        })\n\n        if (!user || !(await compare(credentials.password, user.password))) {\n          return null\n        }\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name\n        }\n      }\n    })\n  ],\n  session: { strategy: \"jwt\" },\n  callbacks: {\n    async session({ session, token }) {\n      if (token) {\n        session.user.id = token.id\n      }\n      return session\n    },\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id\n      }\n      return token\n    }\n  },\n  pages: {\n    signIn: '/login',\n    signOut: '/',\n    error: '/login'\n  }\n}\n\nconst handler = NextAuth(authOptions)\nexport { handler as GET, handler as POST }\n```\n4. 회원가입 API 구현 (비밀번호 해싱 포함):\n```typescript\n// app/api/auth/register/route.ts\nimport { NextResponse } from 'next/server'\nimport { hash } from 'bcrypt'\nimport { prisma } from '@/lib/prisma'\n\nexport async function POST(req: Request) {\n  try {\n    const { name, email, password } = await req.json()\n    \n    // 이메일 중복 확인\n    const existingUser = await prisma.user.findUnique({\n      where: { email }\n    })\n    \n    if (existingUser) {\n      return NextResponse.json(\n        { error: '이미 사용 중인 이메일입니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 비밀번호 해싱\n    const hashedPassword = await hash(password, 10)\n    \n    // 사용자 생성\n    const user = await prisma.user.create({\n      data: {\n        name,\n        email,\n        password: hashedPassword\n      }\n    })\n    \n    return NextResponse.json(\n      { message: '회원가입이 완료되었습니다.', userId: user.id },\n      { status: 201 }\n    )\n  } catch (error) {\n    console.error('회원가입 오류:', error)\n    return NextResponse.json(\n      { error: '회원가입 처리 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n5. 인증 상태 관리를 위한 클라이언트 컴포넌트 구현\n6. 보호된 라우트 구현 (미들웨어 활용)\n7. 사용자 프로필 관리 기능 구현",
        "testStrategy": "1. 회원가입 프로세스 테스트\n2. 로그인/로그아웃 기능 테스트\n3. 비밀번호 해싱 검증\n4. JWT 토큰 생성 및 검증 테스트\n5. 보호된 라우트 접근 제어 테스트\n6. 세션 지속성 테스트\n7. 오류 처리 및 유효성 검사 테스트",
        "priority": "high",
        "dependencies": [
          11,
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "리치 텍스트 에디터 구현",
        "description": "마크다운 지원, 실시간 자동 저장, 이미지 및 파일 첨부 기능을 갖춘 리치 텍스트 에디터를 구현합니다.",
        "details": "1. 에디터 라이브러리 설치: `npm install @tiptap/react @tiptap/pm @tiptap/starter-kit @tiptap/extension-image @tiptap/extension-placeholder @tiptap/extension-link @tiptap/extension-code-block-lowlight lowlight`\n2. 마크다운 지원 에디터 컴포넌트 구현:\n```typescript\n// components/editor/RichTextEditor.tsx\n'use client'\n\nimport { useEditor, EditorContent } from '@tiptap/react'\nimport StarterKit from '@tiptap/starter-kit'\nimport Image from '@tiptap/extension-image'\nimport Link from '@tiptap/extension-link'\nimport Placeholder from '@tiptap/extension-placeholder'\nimport CodeBlockLowlight from '@tiptap/extension-code-block-lowlight'\nimport { lowlight } from 'lowlight'\nimport { useCallback, useEffect } from 'react'\nimport EditorToolbar from './EditorToolbar'\n\ninterface RichTextEditorProps {\n  content: string\n  onChange: (content: string) => void\n  placeholder?: string\n  autofocus?: boolean\n}\n\nexport default function RichTextEditor({\n  content,\n  onChange,\n  placeholder = '내용을 입력하세요...',\n  autofocus = false,\n}: RichTextEditorProps) {\n  const editor = useEditor({\n    extensions: [\n      StarterKit,\n      Image,\n      Link.configure({\n        openOnClick: false,\n        validate: href => /^https?:\\/\\//.test(href),\n      }),\n      Placeholder.configure({\n        placeholder,\n      }),\n      CodeBlockLowlight.configure({\n        lowlight,\n      }),\n    ],\n    content,\n    autofocus,\n    onUpdate: ({ editor }) => {\n      onChange(editor.getHTML())\n    },\n  })\n\n  // 자동 저장 로직\n  const autoSave = useCallback(() => {\n    if (editor) {\n      const currentContent = editor.getHTML()\n      // 여기서 자동 저장 API 호출\n      console.log('자동 저장:', currentContent)\n    }\n  }, [editor])\n\n  useEffect(() => {\n    const interval = setInterval(autoSave, 5000) // 5초마다 자동 저장\n    return () => clearInterval(interval)\n  }, [autoSave])\n\n  // 이미지 업로드 핸들러\n  const handleImageUpload = useCallback(\n    async (file: File) => {\n      if (!editor) return\n      \n      const formData = new FormData()\n      formData.append('file', file)\n      \n      try {\n        const response = await fetch('/api/upload', {\n          method: 'POST',\n          body: formData,\n        })\n        \n        const data = await response.json()\n        \n        if (data.url) {\n          editor\n            .chain()\n            .focus()\n            .setImage({ src: data.url })\n            .run()\n        }\n      } catch (error) {\n        console.error('이미지 업로드 오류:', error)\n      }\n    },\n    [editor]\n  )\n\n  if (!editor) {\n    return null\n  }\n\n  return (\n    <div className=\"border rounded-lg overflow-hidden\">\n      <EditorToolbar editor={editor} onImageUpload={handleImageUpload} />\n      <EditorContent editor={editor} className=\"p-4 min-h-[300px] prose max-w-none\" />\n    </div>\n  )\n}\n```\n3. 에디터 툴바 컴포넌트 구현\n4. 이미지 및 파일 업로드 API 구현 (AWS S3 연동)\n5. 마크다운 변환 기능 구현\n6. 자동 저장 기능 구현 (디바운싱 적용)\n7. 에디터 상태 관리 및 복원 기능",
        "testStrategy": "1. 에디터 기본 기능 테스트 (텍스트 입력, 서식 적용)\n2. 마크다운 변환 정확성 테스트\n3. 이미지 업로드 및 표시 테스트\n4. 자동 저장 기능 테스트\n5. 다양한 브라우저 호환성 테스트\n6. 모바일 환경 반응형 테스트\n7. 에디터 상태 복원 테스트",
        "priority": "high",
        "dependencies": [
          11,
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "메모 CRUD 기능 구현",
        "description": "메모 생성, 조회, 수정, 삭제 기능을 구현하고 메모 목록 페이지와 상세 페이지를 개발합니다.",
        "details": "1. 메모 관련 API 엔드포인트 구현:\n```typescript\n// app/api/memos/route.ts - 메모 생성 및 목록 조회\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { prisma } from '@/lib/prisma'\nimport { authOptions } from '../auth/[...nextauth]/route'\n\n// 메모 목록 조회\nexport async function GET(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n\n    const { searchParams } = new URL(req.url)\n    const limit = parseInt(searchParams.get('limit') || '10')\n    const page = parseInt(searchParams.get('page') || '1')\n    const search = searchParams.get('search') || ''\n    const tagId = searchParams.get('tagId')\n\n    const skip = (page - 1) * limit\n    \n    // 검색 조건 구성\n    const where: any = {\n      userId: session.user.id,\n    }\n    \n    if (search) {\n      where.OR = [\n        { title: { contains: search, mode: 'insensitive' } },\n        { content: { contains: search, mode: 'insensitive' } },\n      ]\n    }\n    \n    if (tagId) {\n      where.tags = {\n        some: {\n          tagId,\n        },\n      }\n    }\n    \n    // 메모 조회\n    const [memos, total] = await Promise.all([\n      prisma.memo.findMany({\n        where,\n        orderBy: { updatedAt: 'desc' },\n        skip,\n        take: limit,\n        include: {\n          tags: {\n            include: {\n              tag: true,\n            },\n          },\n        },\n      }),\n      prisma.memo.count({ where }),\n    ])\n    \n    // 응답 데이터 구성\n    const formattedMemos = memos.map(memo => ({\n      ...memo,\n      tags: memo.tags.map(t => t.tag),\n    }))\n    \n    return NextResponse.json({\n      memos: formattedMemos,\n      pagination: {\n        total,\n        pages: Math.ceil(total / limit),\n        page,\n        limit,\n      },\n    })\n  } catch (error) {\n    console.error('메모 목록 조회 오류:', error)\n    return NextResponse.json(\n      { error: '메모 목록을 불러오는 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n\n// 메모 생성\nexport async function POST(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const { title, content, isPublic = false, tagIds = [] } = await req.json()\n    \n    if (!title || !content) {\n      return NextResponse.json(\n        { error: '제목과 내용은 필수 입력 항목입니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 트랜잭션으로 메모 및 태그 관계 생성\n    const memo = await prisma.$transaction(async (tx) => {\n      // 메모 생성\n      const newMemo = await tx.memo.create({\n        data: {\n          title,\n          content,\n          isPublic,\n          userId: session.user.id,\n        },\n      })\n      \n      // 태그 연결\n      if (tagIds.length > 0) {\n        await Promise.all(\n          tagIds.map(tagId =>\n            tx.tagsOnMemos.create({\n              data: {\n                memoId: newMemo.id,\n                tagId,\n              },\n            })\n          )\n        )\n      }\n      \n      return newMemo\n    })\n    \n    return NextResponse.json(memo, { status: 201 })\n  } catch (error) {\n    console.error('메모 생성 오류:', error)\n    return NextResponse.json(\n      { error: '메모 생성 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n2. 메모 상세, 수정, 삭제 API 구현 (`/app/api/memos/[id]/route.ts`)\n3. 메모 목록 페이지 구현 (`/app/memos/page.tsx`)\n4. 메모 상세 페이지 구현 (`/app/memos/[id]/page.tsx`)\n5. 메모 생성/편집 페이지 구현 (`/app/memos/new/page.tsx`, `/app/memos/[id]/edit/page.tsx`)\n6. 메모 컴포넌트 구현 (목록 아이템, 상세 뷰)\n7. 페이지네이션 및 정렬 기능 구현\n8. 실시간 자동 저장 기능 구현",
        "testStrategy": "1. 메모 CRUD 작업 단위 테스트\n2. API 엔드포인트 통합 테스트\n3. 페이지네이션 및 정렬 기능 테스트\n4. 권한 검사 테스트 (본인 메모만 수정/삭제 가능)\n5. 실시간 자동 저장 기능 테스트\n6. 오류 처리 및 예외 상황 테스트\n7. UI 렌더링 및 사용자 인터랙션 테스트",
        "priority": "high",
        "dependencies": [
          11,
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Anthropic Claude API 연동 및 AI 분석 기능 구현",
        "description": "Anthropic Claude API를 연동하여 메모 내용을 분석하고 문법, 스타일, 구조 개선 제안 및 핵심 포인트 추출 기능을 구현합니다.",
        "details": "1. Anthropic Claude API 설정 및 클라이언트 구현:\n```typescript\n// lib/openai.ts\nimport OpenAI from 'openai'\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n})\n\nexport default openai\n```\n2. AI 분석 API 엔드포인트 구현:\n```typescript\n// app/api/ai/analyze/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../../auth/[...nextauth]/route'\nimport openai from '@/lib/openai'\nimport { prisma } from '@/lib/prisma'\n\nexport async function POST(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const { memoId, type } = await req.json()\n    \n    // 메모 조회 및 권한 확인\n    const memo = await prisma.memo.findUnique({\n      where: { id: memoId },\n    })\n    \n    if (!memo) {\n      return NextResponse.json({ error: '메모를 찾을 수 없습니다.' }, { status: 404 })\n    }\n    \n    if (memo.userId !== session.user.id) {\n      return NextResponse.json({ error: '권한이 없습니다.' }, { status: 403 })\n    }\n    \n    // 분석 유형에 따른 프롬프트 구성\n    let prompt = ''\n    switch (type) {\n      case 'grammar':\n        prompt = `다음 텍스트의 문법과 맞춤법을 검토하고 개선 제안을 제공해주세요. 원문을 유지하면서 문법적 오류를 수정해주세요:\\n\\n${memo.content}`\n        break\n      case 'style':\n        prompt = `다음 텍스트의 문체와 표현을 분석하고 더 명확하고 효과적인 표현으로 개선할 수 있는 제안을 제공해주세요:\\n\\n${memo.content}`\n        break\n      case 'structure':\n        prompt = `다음 텍스트의 구조를 분석하고 더 논리적이고 체계적인 구조로 개선할 수 있는 방법을 제안해주세요:\\n\\n${memo.content}`\n        break\n      case 'summary':\n        prompt = `다음 텍스트의 핵심 포인트를 추출하여 간결한 요약을 제공해주세요:\\n\\n${memo.content}`\n        break\n      default:\n        return NextResponse.json({ error: '지원하지 않는 분석 유형입니다.' }, { status: 400 })\n    }\n    \n    // OpenAI API 호출\n    const response = await openai.chat.completions.create({\n      model: 'gpt-4',\n      messages: [\n        { role: 'system', content: '당신은 텍스트 분석 및 개선을 돕는 AI 어시스턴트입니다.' },\n        { role: 'user', content: prompt }\n      ],\n      temperature: 0.7,\n      max_tokens: 1000,\n    })\n    \n    const suggestion = response.choices[0]?.message?.content || '분석 결과를 생성할 수 없습니다.'\n    \n    // AI 제안 저장\n    const aiSuggestion = await prisma.aISuggestion.create({\n      data: {\n        memoId,\n        type,\n        content: suggestion,\n        applied: false,\n      },\n    })\n    \n    return NextResponse.json(aiSuggestion)\n  } catch (error) {\n    console.error('AI 분석 오류:', error)\n    return NextResponse.json(\n      { error: 'AI 분석 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n3. AI 제안 적용 API 구현 (`/app/api/memos/[id]/ai-suggestions/[suggestionId]/apply/route.ts`)\n4. AI 분석 요청 UI 컴포넌트 구현\n5. AI 제안 표시 및 적용 UI 구현\n6. 캐싱 전략 구현 (비용 최적화)\n7. 오류 처리 및 재시도 로직 구현\n8. 사용량 제한 및 모니터링 기능 구현",
        "testStrategy": "1. OpenAI API 연동 테스트\n2. 다양한 분석 유형별 결과 품질 테스트\n3. 오류 처리 및 예외 상황 테스트\n4. 캐싱 효과 검증\n5. 사용량 제한 기능 테스트\n6. 성능 및 응답 시간 측정\n7. UI 인터랙션 및 사용자 경험 테스트",
        "priority": "high",
        "dependencies": [
          11,
          12,
          13,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "태그 시스템 구현",
        "description": "메모 분류를 위한 태그 생성, 관리, 색상 지정 기능과 태그 기반 필터링 시스템을 구현합니다.",
        "details": "1. 태그 관련 API 엔드포인트 구현:\n```typescript\n// app/api/tags/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../auth/[...nextauth]/route'\nimport { prisma } from '@/lib/prisma'\n\n// 태그 목록 조회\nexport async function GET(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const tags = await prisma.tag.findMany({\n      where: { userId: session.user.id },\n      orderBy: { name: 'asc' },\n    })\n    \n    return NextResponse.json(tags)\n  } catch (error) {\n    console.error('태그 목록 조회 오류:', error)\n    return NextResponse.json(\n      { error: '태그 목록을 불러오는 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n\n// 태그 생성\nexport async function POST(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const { name, color = '#3b82f6' } = await req.json()\n    \n    if (!name) {\n      return NextResponse.json(\n        { error: '태그 이름은 필수 입력 항목입니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 중복 태그 확인\n    const existingTag = await prisma.tag.findFirst({\n      where: {\n        name,\n        userId: session.user.id,\n      },\n    })\n    \n    if (existingTag) {\n      return NextResponse.json(\n        { error: '이미 동일한 이름의 태그가 존재합니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 태그 생성\n    const tag = await prisma.tag.create({\n      data: {\n        name,\n        color,\n        userId: session.user.id,\n      },\n    })\n    \n    return NextResponse.json(tag, { status: 201 })\n  } catch (error) {\n    console.error('태그 생성 오류:', error)\n    return NextResponse.json(\n      { error: '태그 생성 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n2. 태그 수정 및 삭제 API 구현 (`/app/api/tags/[id]/route.ts`)\n3. 태그별 메모 조회 API 구현 (`/app/api/tags/[id]/memos/route.ts`)\n4. 태그 관리 UI 컴포넌트 구현\n5. 태그 선택 및 필터링 UI 구현\n6. 태그 색상 선택 기능 구현\n7. 태그 통계 및 사용 빈도 분석 기능 구현",
        "testStrategy": "1. 태그 CRUD 작업 단위 테스트\n2. API 엔드포인트 통합 테스트\n3. 태그 기반 필터링 기능 테스트\n4. 태그 색상 적용 테스트\n5. 중복 태그 처리 테스트\n6. 태그 통계 계산 정확성 테스트\n7. UI 렌더링 및 사용자 인터랙션 테스트",
        "priority": "medium",
        "dependencies": [
          11,
          12,
          13,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "고급 검색 시스템 구현",
        "description": "전체 텍스트 검색, 태그 기반 필터링, 날짜 범위 검색, AI 기반 의미 검색 등 고급 검색 기능을 구현합니다.",
        "details": "1. 고급 검색 API 엔드포인트 구현:\n```typescript\n// app/api/memos/search/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../../auth/[...nextauth]/route'\nimport { prisma } from '@/lib/prisma'\n\nexport async function GET(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const { searchParams } = new URL(req.url)\n    const query = searchParams.get('q') || ''\n    const tagIds = searchParams.getAll('tagId')\n    const startDate = searchParams.get('startDate')\n    const endDate = searchParams.get('endDate')\n    const limit = parseInt(searchParams.get('limit') || '10')\n    const page = parseInt(searchParams.get('page') || '1')\n    const skip = (page - 1) * limit\n    \n    // 검색 조건 구성\n    const where: any = {\n      userId: session.user.id,\n    }\n    \n    // 텍스트 검색\n    if (query) {\n      where.OR = [\n        { title: { contains: query, mode: 'insensitive' } },\n        { content: { contains: query, mode: 'insensitive' } },\n      ]\n    }\n    \n    // 태그 필터링\n    if (tagIds.length > 0) {\n      where.tags = {\n        some: {\n          tagId: { in: tagIds },\n        },\n      }\n    }\n    \n    // 날짜 범위 필터링\n    if (startDate) {\n      where.createdAt = {\n        ...where.createdAt,\n        gte: new Date(startDate),\n      }\n    }\n    \n    if (endDate) {\n      where.createdAt = {\n        ...where.createdAt,\n        lte: new Date(endDate),\n      }\n    }\n    \n    // 메모 검색\n    const [memos, total] = await Promise.all([\n      prisma.memo.findMany({\n        where,\n        orderBy: { updatedAt: 'desc' },\n        skip,\n        take: limit,\n        include: {\n          tags: {\n            include: {\n              tag: true,\n            },\n          },\n        },\n      }),\n      prisma.memo.count({ where }),\n    ])\n    \n    // 응답 데이터 구성\n    const formattedMemos = memos.map(memo => ({\n      ...memo,\n      tags: memo.tags.map(t => t.tag),\n    }))\n    \n    return NextResponse.json({\n      memos: formattedMemos,\n      pagination: {\n        total,\n        pages: Math.ceil(total / limit),\n        page,\n        limit,\n      },\n    })\n  } catch (error) {\n    console.error('메모 검색 오류:', error)\n    return NextResponse.json(\n      { error: '메모 검색 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n2. AI 기반 의미 검색 구현 (OpenAI 임베딩 활용):\n```typescript\n// app/api/memos/semantic-search/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../../auth/[...nextauth]/route'\nimport { prisma } from '@/lib/prisma'\nimport openai from '@/lib/openai'\n\nexport async function GET(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const { searchParams } = new URL(req.url)\n    const query = searchParams.get('q')\n    \n    if (!query) {\n      return NextResponse.json(\n        { error: '검색어를 입력해주세요.' },\n        { status: 400 }\n      )\n    }\n    \n    // 쿼리 임베딩 생성\n    const embeddingResponse = await openai.embeddings.create({\n      model: 'text-embedding-ada-002',\n      input: query,\n    })\n    \n    const queryEmbedding = embeddingResponse.data[0].embedding\n    \n    // 사용자의 모든 메모 가져오기\n    const userMemos = await prisma.memo.findMany({\n      where: { userId: session.user.id },\n      select: {\n        id: true,\n        title: true,\n        content: true,\n        updatedAt: true,\n      },\n    })\n    \n    // 각 메모에 대한 임베딩 생성 (실제로는 미리 계산하여 저장해야 함)\n    const memoEmbeddings = await Promise.all(\n      userMemos.map(async (memo) => {\n        const content = `${memo.title}\\n${memo.content}`\n        const embeddingResponse = await openai.embeddings.create({\n          model: 'text-embedding-ada-002',\n          input: content,\n        })\n        return {\n          memo,\n          embedding: embeddingResponse.data[0].embedding,\n        }\n      })\n    )\n    \n    // 코사인 유사도 계산 및 정렬\n    const results = memoEmbeddings\n      .map(({ memo, embedding }) => {\n        const similarity = calculateCosineSimilarity(queryEmbedding, embedding)\n        return { memo, similarity }\n      })\n      .sort((a, b) => b.similarity - a.similarity)\n      .slice(0, 10) // 상위 10개 결과만 반환\n    \n    return NextResponse.json({\n      results: results.map(r => ({\n        ...r.memo,\n        similarity: r.similarity,\n      })),\n    })\n  } catch (error) {\n    console.error('의미 검색 오류:', error)\n    return NextResponse.json(\n      { error: '의미 검색 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n\n// 코사인 유사도 계산 함수\nfunction calculateCosineSimilarity(vecA: number[], vecB: number[]): number {\n  const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0)\n  const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0))\n  const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0))\n  return dotProduct / (magnitudeA * magnitudeB)\n}\n```\n3. 검색 UI 컴포넌트 구현\n4. 필터 및 정렬 옵션 UI 구현\n5. 검색 결과 하이라이팅 기능 구현\n6. 검색 히스토리 및 추천 검색어 기능 구현\n7. 검색 성능 최적화 (인덱싱, 캐싱)",
        "testStrategy": "1. 다양한 검색 조건 조합 테스트\n2. 검색 결과 정확성 테스트\n3. 태그 필터링 기능 테스트\n4. 날짜 범위 검색 테스트\n5. AI 의미 검색 품질 테스트\n6. 검색 성능 및 응답 시간 측정\n7. 대량 데이터에서의 검색 성능 테스트",
        "priority": "medium",
        "dependencies": [
          11,
          12,
          13,
          15,
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "팀 및 협업 기능 구현",
        "description": "팀 생성, 관리, 멤버 초대 및 권한 관리, 팀 메모 공유 및 협업 기능을 구현합니다.",
        "details": "1. 팀 관련 API 엔드포인트 구현:\n```typescript\n// app/api/teams/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../auth/[...nextauth]/route'\nimport { prisma } from '@/lib/prisma'\n\n// 팀 목록 조회\nexport async function GET(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    // 사용자가 속한 팀 조회\n    const teams = await prisma.team.findMany({\n      where: {\n        members: {\n          some: {\n            userId: session.user.id,\n          },\n        },\n      },\n      include: {\n        members: {\n          include: {\n            user: {\n              select: {\n                id: true,\n                name: true,\n                email: true,\n                avatar: true,\n              },\n            },\n          },\n        },\n        _count: {\n          select: {\n            memos: true,\n          },\n        },\n      },\n    })\n    \n    return NextResponse.json(teams)\n  } catch (error) {\n    console.error('팀 목록 조회 오류:', error)\n    return NextResponse.json(\n      { error: '팀 목록을 불러오는 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n\n// 팀 생성\nexport async function POST(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const { name, description = '' } = await req.json()\n    \n    if (!name) {\n      return NextResponse.json(\n        { error: '팀 이름은 필수 입력 항목입니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 트랜잭션으로 팀 및 멤버 생성\n    const team = await prisma.$transaction(async (tx) => {\n      // 팀 생성\n      const newTeam = await tx.team.create({\n        data: {\n          name,\n          description,\n        },\n      })\n      \n      // 생성자를 팀 소유자로 추가\n      await tx.teamMember.create({\n        data: {\n          teamId: newTeam.id,\n          userId: session.user.id,\n          role: 'owner',\n        },\n      })\n      \n      return newTeam\n    })\n    \n    return NextResponse.json(team, { status: 201 })\n  } catch (error) {\n    console.error('팀 생성 오류:', error)\n    return NextResponse.json(\n      { error: '팀 생성 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n2. 팀 상세, 수정, 삭제 API 구현 (`/app/api/teams/[id]/route.ts`)\n3. 팀원 관리 API 구현 (`/app/api/teams/[id]/members/route.ts`)\n4. 팀 메모 API 구현 (`/app/api/teams/[id]/memos/route.ts`)\n5. 팀 초대 시스템 구현 (이메일 초대)\n6. 팀 관리 UI 컴포넌트 구현\n7. 팀 메모 공유 및 협업 UI 구현\n8. 권한 기반 접근 제어 구현",
        "testStrategy": "1. 팀 CRUD 작업 단위 테스트\n2. 팀원 초대 및 권한 관리 테스트\n3. 팀 메모 공유 및 접근 권한 테스트\n4. 여러 사용자 간 협업 시나리오 테스트\n5. 권한 기반 접근 제어 테스트\n6. 이메일 초대 기능 테스트\n7. UI 렌더링 및 사용자 인터랙션 테스트",
        "priority": "medium",
        "dependencies": [
          11,
          12,
          13,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Supabase Realtime 협업 기능 구현",
        "description": "Supabase Realtime을 활용한 실시간 메모 편집, 변경 사항 추적, 댓글 및 피드백 시스템을 구현합니다.",
        "details": "1. WebSocket 서버 설정 (Socket.io 활용):\n```typescript\n// lib/socket.ts\nimport { Server as HTTPServer } from 'http'\nimport { Server as IOServer } from 'socket.io'\nimport { NextApiRequest } from 'next'\nimport { getToken } from 'next-auth/jwt'\n\nexport const initSocketServer = (httpServer: HTTPServer) => {\n  const io = new IOServer(httpServer, {\n    path: '/api/socketio',\n    cors: {\n      origin: process.env.NEXTAUTH_URL,\n      methods: ['GET', 'POST'],\n      credentials: true,\n    },\n  })\n  \n  // 인증 미들웨어\n  io.use(async (socket, next) => {\n    try {\n      const req = socket.request as NextApiRequest\n      const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET })\n      \n      if (!token) {\n        return next(new Error('인증이 필요합니다.'))\n      }\n      \n      socket.data.user = {\n        id: token.id,\n        name: token.name,\n        email: token.email,\n      }\n      \n      next()\n    } catch (error) {\n      next(new Error('인증 처리 중 오류가 발생했습니다.'))\n    }\n  })\n  \n  // 연결 이벤트 처리\n  io.on('connection', (socket) => {\n    console.log(`사용자 연결됨: ${socket.data.user.id}`)\n    \n    // 메모 룸 참여\n    socket.on('join-memo', (memoId) => {\n      socket.join(`memo:${memoId}`)\n      console.log(`사용자 ${socket.data.user.id}가 메모 ${memoId}에 참여함`)\n      \n      // 참여 알림\n      socket.to(`memo:${memoId}`).emit('user-joined', {\n        userId: socket.data.user.id,\n        userName: socket.data.user.name,\n      })\n    })\n    \n    // 메모 룸 퇴장\n    socket.on('leave-memo', (memoId) => {\n      socket.leave(`memo:${memoId}`)\n      console.log(`사용자 ${socket.data.user.id}가 메모 ${memoId}에서 퇴장함`)\n      \n      // 퇴장 알림\n      socket.to(`memo:${memoId}`).emit('user-left', {\n        userId: socket.data.user.id,\n        userName: socket.data.user.name,\n      })\n    })\n    \n    // 메모 내용 변경\n    socket.on('memo-change', ({ memoId, content, cursorPosition }) => {\n      socket.to(`memo:${memoId}`).emit('memo-updated', {\n        userId: socket.data.user.id,\n        userName: socket.data.user.name,\n        content,\n        cursorPosition,\n        timestamp: new Date(),\n      })\n    })\n    \n    // 댓글 추가\n    socket.on('add-comment', ({ memoId, comment }) => {\n      socket.to(`memo:${memoId}`).emit('new-comment', {\n        userId: socket.data.user.id,\n        userName: socket.data.user.name,\n        comment,\n        timestamp: new Date(),\n      })\n    })\n    \n    // 연결 해제\n    socket.on('disconnect', () => {\n      console.log(`사용자 연결 해제됨: ${socket.data.user.id}`)\n    })\n  })\n  \n  return io\n}\n```\n2. 클라이언트 Socket.io 연결 구현:\n```typescript\n// lib/socketClient.ts\nimport { io, Socket } from 'socket.io-client'\nimport { useEffect, useState } from 'react'\n\nlet socket: Socket | null = null\n\nexport const initSocket = () => {\n  if (!socket) {\n    socket = io(process.env.NEXT_PUBLIC_SITE_URL || '', {\n      path: '/api/socketio',\n      withCredentials: true,\n    })\n  }\n  return socket\n}\n\nexport const useSocket = () => {\n  const [isConnected, setIsConnected] = useState(false)\n  \n  useEffect(() => {\n    const socketInstance = initSocket()\n    \n    const onConnect = () => {\n      setIsConnected(true)\n      console.log('Socket 연결됨')\n    }\n    \n    const onDisconnect = () => {\n      setIsConnected(false)\n      console.log('Socket 연결 해제됨')\n    }\n    \n    socketInstance.on('connect', onConnect)\n    socketInstance.on('disconnect', onDisconnect)\n    \n    if (socketInstance.connected) {\n      setIsConnected(true)\n    }\n    \n    return () => {\n      socketInstance.off('connect', onConnect)\n      socketInstance.off('disconnect', onDisconnect)\n    }\n  }, [])\n  \n  return { socket: socket as Socket, isConnected }\n}\n```\n3. 실시간 협업 에디터 구현 (TipTap + Y.js 활용)\n4. 변경 사항 추적 및 충돌 해결 로직 구현\n5. 실시간 댓글 및 피드백 시스템 구현\n6. 사용자 온라인 상태 표시 기능 구현\n7. 알림 시스템 구현 (실시간 + 이메일)",
        "testStrategy": "1. WebSocket 연결 및 이벤트 처리 테스트\n2. 여러 사용자 동시 편집 시나리오 테스트\n3. 네트워크 지연 및 연결 끊김 상황 테스트\n4. 충돌 해결 로직 테스트\n5. 실시간 알림 전달 테스트\n6. 대규모 동시 접속 성능 테스트\n7. 브라우저 호환성 테스트",
        "priority": "medium",
        "dependencies": [
          11,
          12,
          13,
          15,
          19
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "파일 업로드 및 Supabase Storage 시스템 구현",
        "description": "Supabase Storage를 활용한 이미지 및 파일 업로드, 저장, 관리 시스템을 구현합니다.",
        "details": "1. AWS S3 설정 및 클라이언트 구현:\n```typescript\n// lib/s3.ts\nimport { S3Client, PutObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3'\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'\nimport crypto from 'crypto'\n\nconst s3Client = new S3Client({\n  region: process.env.AWS_REGION!,\n  credentials: {\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,\n  },\n})\n\nconst BUCKET_NAME = process.env.AWS_S3_BUCKET_NAME!\n\n// 파일 업로드 함수\nexport async function uploadFile(file: Buffer, fileName: string, contentType: string) {\n  // 고유한 파일명 생성\n  const fileKey = `uploads/${crypto.randomUUID()}-${fileName}`\n  \n  const command = new PutObjectCommand({\n    Bucket: BUCKET_NAME,\n    Key: fileKey,\n    Body: file,\n    ContentType: contentType,\n  })\n  \n  await s3Client.send(command)\n  \n  return {\n    url: `https://${BUCKET_NAME}.s3.${process.env.AWS_REGION}.amazonaws.com/${fileKey}`,\n    key: fileKey,\n  }\n}\n\n// 파일 삭제 함수\nexport async function deleteFile(fileKey: string) {\n  const command = new DeleteObjectCommand({\n    Bucket: BUCKET_NAME,\n    Key: fileKey,\n  })\n  \n  await s3Client.send(command)\n}\n\n// 서명된 URL 생성 함수 (클라이언트에서 직접 업로드용)\nexport async function getPresignedUrl(fileName: string, contentType: string) {\n  const fileKey = `uploads/${crypto.randomUUID()}-${fileName}`\n  \n  const command = new PutObjectCommand({\n    Bucket: BUCKET_NAME,\n    Key: fileKey,\n    ContentType: contentType,\n  })\n  \n  const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 })\n  \n  return {\n    signedUrl,\n    fileKey,\n    url: `https://${BUCKET_NAME}.s3.${process.env.AWS_REGION}.amazonaws.com/${fileKey}`,\n  }\n}\n```\n2. 파일 업로드 API 엔드포인트 구현:\n```typescript\n// app/api/upload/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../auth/[...nextauth]/route'\nimport { uploadFile } from '@/lib/s3'\n\nexport async function POST(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const formData = await req.formData()\n    const file = formData.get('file') as File\n    \n    if (!file) {\n      return NextResponse.json(\n        { error: '파일이 제공되지 않았습니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 파일 크기 제한 (10MB)\n    if (file.size > 10 * 1024 * 1024) {\n      return NextResponse.json(\n        { error: '파일 크기는 10MB를 초과할 수 없습니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 허용된 파일 타입 확인\n    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf']\n    if (!allowedTypes.includes(file.type)) {\n      return NextResponse.json(\n        { error: '지원되지 않는 파일 형식입니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 파일 버퍼로 변환\n    const buffer = Buffer.from(await file.arrayBuffer())\n    \n    // S3에 업로드\n    const result = await uploadFile(buffer, file.name, file.type)\n    \n    return NextResponse.json({\n      url: result.url,\n      key: result.key,\n    })\n  } catch (error) {\n    console.error('파일 업로드 오류:', error)\n    return NextResponse.json(\n      { error: '파일 업로드 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n3. 프리사인드 URL API 구현 (대용량 파일 직접 업로드용)\n4. 파일 삭제 API 구현\n5. 파일 업로드 UI 컴포넌트 구현\n6. 이미지 미리보기 및 갤러리 기능 구현\n7. 파일 형식 및 크기 검증 로직 구현\n8. CDN 설정 및 최적화",
        "testStrategy": "1. 다양한 파일 형식 업로드 테스트\n2. 대용량 파일 업로드 테스트\n3. 파일 삭제 기능 테스트\n4. 권한 검증 테스트\n5. 오류 처리 및 예외 상황 테스트\n6. 업로드 진행률 표시 테스트\n7. CDN 캐싱 및 성능 테스트",
        "priority": "medium",
        "dependencies": [
          11,
          12,
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "대시보드 및 분석 기능 구현",
        "description": "사용자 활동, 메모 통계, AI 활용도 등을 시각화하는 대시보드 및 분석 기능을 구현합니다.",
        "details": "1. 대시보드 데이터 API 엔드포인트 구현:\n```typescript\n// app/api/dashboard/stats/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../../auth/[...nextauth]/route'\nimport { prisma } from '@/lib/prisma'\n\nexport async function GET(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    // 기간 파라미터 (기본: 30일)\n    const { searchParams } = new URL(req.url)\n    const days = parseInt(searchParams.get('days') || '30')\n    const startDate = new Date()\n    startDate.setDate(startDate.getDate() - days)\n    \n    // 병렬로 여러 통계 데이터 조회\n    const [totalMemos, recentMemos, totalTags, aiSuggestions, popularTags, activityByDay] = await Promise.all([\n      // 총 메모 수\n      prisma.memo.count({\n        where: { userId: session.user.id },\n      }),\n      \n      // 최근 메모 수\n      prisma.memo.count({\n        where: {\n          userId: session.user.id,\n          createdAt: { gte: startDate },\n        },\n      }),\n      \n      // 총 태그 수\n      prisma.tag.count({\n        where: { userId: session.user.id },\n      }),\n      \n      // AI 제안 통계\n      prisma.aISuggestion.groupBy({\n        by: ['type'],\n        where: {\n          memo: { userId: session.user.id },\n          createdAt: { gte: startDate },\n        },\n        _count: true,\n      }),\n      \n      // 인기 태그\n      prisma.tag.findMany({\n        where: { userId: session.user.id },\n        select: {\n          id: true,\n          name: true,\n          color: true,\n          _count: {\n            select: { memos: true },\n          },\n        },\n        orderBy: {\n          memos: { _count: 'desc' },\n        },\n        take: 5,\n      }),\n      \n      // 일별 활동\n      prisma.memo.groupBy({\n        by: ['createdAt'],\n        where: {\n          userId: session.user.id,\n          createdAt: { gte: startDate },\n        },\n        _count: true,\n      }),\n    ])\n    \n    // 일별 활동 데이터 가공\n    const activityMap = new Map()\n    const today = new Date()\n    \n    // 모든 날짜 초기화 (0으로)\n    for (let i = 0; i < days; i++) {\n      const date = new Date(today)\n      date.setDate(date.getDate() - i)\n      const dateStr = date.toISOString().split('T')[0]\n      activityMap.set(dateStr, 0)\n    }\n    \n    // 실제 활동 데이터 채우기\n    activityByDay.forEach(day => {\n      const dateStr = day.createdAt.toISOString().split('T')[0]\n      activityMap.set(dateStr, day._count)\n    })\n    \n    // 응답 데이터 구성\n    const stats = {\n      totalMemos,\n      recentMemos,\n      totalTags,\n      aiSuggestions: aiSuggestions.reduce((acc, curr) => {\n        acc[curr.type] = curr._count\n        return acc\n      }, {} as Record<string, number>),\n      popularTags: popularTags.map(tag => ({\n        id: tag.id,\n        name: tag.name,\n        color: tag.color,\n        count: tag._count.memos,\n      })),\n      activityByDay: Array.from(activityMap.entries()).map(([date, count]) => ({\n        date,\n        count,\n      })).sort((a, b) => a.date.localeCompare(b.date)),\n    }\n    \n    return NextResponse.json(stats)\n  } catch (error) {\n    console.error('대시보드 통계 조회 오류:', error)\n    return NextResponse.json(\n      { error: '통계 데이터를 불러오는 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n2. 팀 활동 분석 API 구현\n3. 데이터 시각화 컴포넌트 구현 (Chart.js 활용)\n4. 대시보드 페이지 구현\n5. 사용자 활동 추적 시스템 구현\n6. 메모 사용 패턴 분석 기능 구현\n7. AI 활용도 분석 기능 구현",
        "testStrategy": "1. 통계 데이터 계산 정확성 테스트\n2. 다양한 기간 설정에 따른 데이터 변화 테스트\n3. 차트 렌더링 및 반응형 디자인 테스트\n4. 대량 데이터에서의 성능 테스트\n5. 데이터 필터링 및 정렬 기능 테스트\n6. 사용자 활동 추적 정확성 테스트\n7. UI 렌더링 및 사용자 인터랙션 테스트",
        "priority": "low",
        "dependencies": [
          11,
          12,
          13,
          15,
          16,
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "알림 시스템 구현",
        "description": "실시간 알림, 이메일 알림, 푸시 알림 등 다양한 알림 시스템을 구현합니다.",
        "details": "1. 알림 모델 및 API 구현:\n```typescript\n// prisma/schema.prisma에 추가\nmodel Notification {\n  id        String   @id @default(cuid())\n  userId    String\n  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n  type      String   // 'memo_comment', 'team_invite', 'ai_suggestion', 등\n  title     String\n  content   String\n  link      String?\n  read      Boolean  @default(false)\n  createdAt DateTime @default(now())\n}\n```\n\n```typescript\n// app/api/notifications/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../auth/[...nextauth]/route'\nimport { prisma } from '@/lib/prisma'\n\n// 알림 목록 조회\nexport async function GET(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const { searchParams } = new URL(req.url)\n    const limit = parseInt(searchParams.get('limit') || '20')\n    const page = parseInt(searchParams.get('page') || '1')\n    const unreadOnly = searchParams.get('unreadOnly') === 'true'\n    \n    const skip = (page - 1) * limit\n    \n    // 검색 조건 구성\n    const where: any = {\n      userId: session.user.id,\n    }\n    \n    if (unreadOnly) {\n      where.read = false\n    }\n    \n    // 알림 조회\n    const [notifications, total, unreadCount] = await Promise.all([\n      prisma.notification.findMany({\n        where,\n        orderBy: { createdAt: 'desc' },\n        skip,\n        take: limit,\n      }),\n      prisma.notification.count({ where }),\n      prisma.notification.count({\n        where: {\n          userId: session.user.id,\n          read: false,\n        },\n      }),\n    ])\n    \n    return NextResponse.json({\n      notifications,\n      pagination: {\n        total,\n        pages: Math.ceil(total / limit),\n        page,\n        limit,\n      },\n      unreadCount,\n    })\n  } catch (error) {\n    console.error('알림 목록 조회 오류:', error)\n    return NextResponse.json(\n      { error: '알림 목록을 불러오는 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n2. 알림 읽음 표시 API 구현\n3. 알림 생성 유틸리티 함수 구현:\n```typescript\n// lib/notifications.ts\nimport { prisma } from './prisma'\nimport { sendEmail } from './email'\n\ntype NotificationType = 'memo_comment' | 'team_invite' | 'ai_suggestion' | 'memo_share'\n\ninterface CreateNotificationParams {\n  userId: string\n  type: NotificationType\n  title: string\n  content: string\n  link?: string\n  emailNotification?: boolean\n}\n\nexport async function createNotification({\n  userId,\n  type,\n  title,\n  content,\n  link,\n  emailNotification = false,\n}: CreateNotificationParams) {\n  // 데이터베이스에 알림 생성\n  const notification = await prisma.notification.create({\n    data: {\n      userId,\n      type,\n      title,\n      content,\n      link,\n    },\n    include: {\n      user: true,\n    },\n  })\n  \n  // 실시간 알림 전송 (Socket.io 활용)\n  if (global.io) {\n    global.io.to(`user:${userId}`).emit('new-notification', notification)\n  }\n  \n  // 이메일 알림 전송\n  if (emailNotification && notification.user.email) {\n    await sendEmail({\n      to: notification.user.email,\n      subject: title,\n      text: content,\n      html: `<p>${content}</p>${link ? `<p><a href=\"${link}\">자세히 보기</a></p>` : ''}`,\n    })\n  }\n  \n  return notification\n}\n```\n4. 실시간 알림 시스템 구현 (Socket.io 활용)\n5. 이메일 알림 시스템 구현 (Nodemailer 활용)\n6. 푸시 알림 시스템 구현 (웹 푸시 API 활용)\n7. 알림 설정 및 관리 UI 구현\n8. 알림 센터 UI 구현",
        "testStrategy": "1. 알림 생성 및 조회 기능 테스트\n2. 실시간 알림 전송 테스트\n3. 이메일 알림 전송 테스트\n4. 푸시 알림 전송 테스트\n5. 알림 읽음 표시 기능 테스트\n6. 알림 설정 저장 및 적용 테스트\n7. 다양한 알림 유형 및 시나리오 테스트",
        "priority": "low",
        "dependencies": [
          11,
          12,
          13,
          15,
          19,
          20
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "내보내기 및 백업 기능 구현",
        "description": "메모를 다양한 형식(PDF, Markdown, Word)으로 내보내기 및 자동 백업 기능을 구현합니다.",
        "details": "1. PDF 내보내기 기능 구현 (react-pdf 활용):\n```typescript\n// app/api/memos/[id]/export/pdf/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../../../../auth/[...nextauth]/route'\nimport { prisma } from '@/lib/prisma'\nimport PDFDocument from 'pdfkit'\n\nexport async function GET(req: Request, { params }: { params: { id: string } }) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const memoId = params.id\n    \n    // 메모 조회 및 권한 확인\n    const memo = await prisma.memo.findUnique({\n      where: { id: memoId },\n      include: {\n        user: {\n          select: {\n            name: true,\n          },\n        },\n        tags: {\n          include: {\n            tag: true,\n          },\n        },\n      },\n    })\n    \n    if (!memo) {\n      return NextResponse.json({ error: '메모를 찾을 수 없습니다.' }, { status: 404 })\n    }\n    \n    if (memo.userId !== session.user.id && !memo.isPublic) {\n      return NextResponse.json({ error: '권한이 없습니다.' }, { status: 403 })\n    }\n    \n    // PDF 생성\n    const pdfBuffer = await new Promise<Buffer>((resolve) => {\n      const doc = new PDFDocument({\n        margin: 50,\n        size: 'A4',\n      })\n      \n      const chunks: Buffer[] = []\n      doc.on('data', (chunk) => chunks.push(chunk))\n      doc.on('end', () => resolve(Buffer.concat(chunks)))\n      \n      // PDF 내용 작성\n      doc.fontSize(24).text(memo.title, { align: 'center' })\n      doc.moveDown()\n      \n      // 메타 정보\n      doc.fontSize(10).text(`작성자: ${memo.user.name}`, { align: 'left' })\n      doc.fontSize(10).text(`작성일: ${memo.createdAt.toLocaleDateString('ko-KR')}`, { align: 'left' })\n      \n      // 태그\n      if (memo.tags.length > 0) {\n        const tagNames = memo.tags.map(t => t.tag.name).join(', ')\n        doc.fontSize(10).text(`태그: ${tagNames}`, { align: 'left' })\n      }\n      \n      doc.moveDown()\n      doc.moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke()\n      doc.moveDown()\n      \n      // 본문 내용 (HTML을 텍스트로 변환하여 삽입)\n      const contentText = memo.content.replace(/<[^>]*>/g, '')\n      doc.fontSize(12).text(contentText, {\n        align: 'left',\n        lineGap: 5,\n      })\n      \n      doc.end()\n    })\n    \n    // 응답 헤더 설정\n    const headers = new Headers()\n    headers.set('Content-Type', 'application/pdf')\n    headers.set('Content-Disposition', `attachment; filename=\"${encodeURIComponent(memo.title)}.pdf\"`)\n    \n    return new NextResponse(pdfBuffer, {\n      status: 200,\n      headers,\n    })\n  } catch (error) {\n    console.error('PDF 내보내기 오류:', error)\n    return NextResponse.json(\n      { error: 'PDF 생성 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n2. Markdown 내보내기 기능 구현\n3. Word(DOCX) 내보내기 기능 구현 (docx 라이브러리 활용)\n4. 메모 백업 API 구현 (전체 메모 JSON/CSV 내보내기)\n5. 자동 백업 스케줄링 구현 (Vercel Cron 활용)\n6. 백업 복원 기능 구현\n7. 내보내기 및 백업 UI 구현",
        "testStrategy": "1. 다양한 형식 내보내기 결과 검증\n2. 대용량 메모 내보내기 성능 테스트\n3. 백업 생성 및 복원 기능 테스트\n4. 자동 백업 스케줄링 테스트\n5. 다양한 메모 형식 및 콘텐츠 처리 테스트\n6. 오류 처리 및 예외 상황 테스트\n7. UI 인터랙션 및 사용자 경험 테스트",
        "priority": "low",
        "dependencies": [
          11,
          12,
          13,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "성능 최적화 및 배포 준비",
        "description": "애플리케이션 성능 최적화, 코드 리팩토링, 보안 강화, 모니터링 설정 및 배포 준비를 수행합니다.",
        "details": "1. 성능 최적화:\n   - 컴포넌트 메모이제이션 (React.memo, useMemo, useCallback)\n   - 이미지 최적화 (next/image 활용)\n   - 코드 스플리팅 및 지연 로딩\n   - API 응답 캐싱 (SWR 또는 React Query 활용)\n   - 데이터베이스 쿼리 최적화\n\n2. 보안 강화:\n   - CSRF 보호 구현\n   - XSS 방어 (DOMPurify 활용)\n   - 입력 데이터 검증 및 살균\n   - 레이트 리미팅 구현\n   - 보안 헤더 설정\n\n3. 모니터링 설정:\n   - Sentry 통합 구현:\n```typescript\n// app/sentry.ts\nimport * as Sentry from '@sentry/nextjs'\n\nSentry.init({\n  dsn: process.env.SENTRY_DSN,\n  tracesSampleRate: 1.0,\n  profilesSampleRate: 1.0,\n  environment: process.env.NODE_ENV,\n})\n```\n   - Vercel Analytics 설정\n   - 로깅 시스템 구현\n   - 성능 모니터링 설정\n\n4. 배포 준비:\n   - 환경 변수 설정 및 검증\n   - 빌드 스크립트 최적화\n   - CI/CD 파이프라인 구성 (GitHub Actions)\n   - 데이터베이스 마이그레이션 계획\n\n5. 코드 리팩토링:\n   - 중복 코드 제거\n   - 컴포넌트 구조 최적화\n   - 타입 정의 개선\n   - 에러 처리 일관성 확보\n\n6. 테스트 자동화:\n   - 단위 테스트 작성 (Jest + React Testing Library)\n   - API 통합 테스트 작성\n   - E2E 테스트 작성 (Playwright 또는 Cypress)\n   - 성능 테스트 자동화",
        "testStrategy": "1. 성능 측정 및 개선 효과 검증\n   - Lighthouse 점수 측정\n   - Core Web Vitals 모니터링\n   - 로딩 시간 및 인터랙션 지연 측정\n   - 메모리 사용량 분석\n\n2. 보안 취약점 테스트\n   - OWASP Top 10 취약점 점검\n   - 침투 테스트 수행\n   - 입력 검증 테스트\n   - 권한 검증 테스트\n\n3. 확장성 테스트\n   - 대량 데이터 처리 테스트\n   - 동시 사용자 부하 테스트\n   - 데이터베이스 성능 테스트\n\n4. 배포 프로세스 검증\n   - 다양한 환경에서의 배포 테스트\n   - 롤백 프로세스 테스트\n   - 마이그레이션 테스트",
        "priority": "high",
        "dependencies": [
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-28T04:58:29.491Z",
      "updated": "2025-07-28T05:27:39.812Z",
      "description": "Tasks for master context"
    }
  }
}