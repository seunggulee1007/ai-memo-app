{
  "master": {
    "tasks": [
      {
        "id": 11,
        "title": "프로젝트 초기 설정 및 기본 구조 구축",
        "description": "Next.js 15와 React 19 기반의 프로젝트를 설정하고 기본 폴더 구조와 환경 설정을 완료합니다.",
        "details": "1. Next.js 15 프로젝트 생성: `npx create-next-app@latest ai-memo-app --typescript --tailwind --app`\n2. 필수 패키지 설치: React 19, TypeScript, Tailwind CSS, ESLint, Prettier\n3. 폴더 구조 설정:\n   - `/app`: App Router 기반 페이지 구조\n   - `/components`: 재사용 가능한 UI 컴포넌트\n   - `/lib`: 유틸리티 함수 및 헬퍼\n   - `/drizzle`: 데이터베이스 스키마 및 클라이언트\n   - `/public`: 정적 파일\n4. 환경 변수 설정 (.env.local, .env.example)\n5. TypeScript 설정 (tsconfig.json)\n6. Tailwind CSS 설정 및 테마 구성 (다크모드 지원)\n7. ESLint 및 Prettier 설정\n8. Git 저장소 초기화 및 .gitignore 설정",
        "testStrategy": "1. 프로젝트 빌드 및 개발 서버 실행 테스트\n2. TypeScript 타입 체크 검증\n3. ESLint 및 Prettier 규칙 준수 확인\n4. 다크모드/라이트모드 전환 테스트\n5. 폴더 구조 및 파일 구성 검토",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "데이터베이스 설정 및 DrizzleORM 스키마 구현",
        "description": "Supabase PostgreSQL 데이터베이스를 설정하고 DrizzleORM을 통해 PRD에 정의된 데이터 모델을 구현합니다.",
        "details": "1. Supabase PostgreSQL 데이터베이스 설정\n2. DrizzleORM 설치 및 초기화: `npm install drizzle-orm pg @supabase/supabase-js`\n3. DrizzleORM 스키마 정의 (schema.ts):\n```typescript\n// drizzle/schema.ts\nimport { pgTable, text, timestamp, boolean, primaryKey } from 'drizzle-orm/pg-core';\nimport { relations } from 'drizzle-orm';\n\nexport const users = pgTable('users', {\n  id: text('id').primaryKey().notNull(),\n  email: text('email').unique().notNull(),\n  name: text('name').notNull(),\n  avatar: text('avatar'),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull(),\n});\n\nexport const memos = pgTable('memos', {\n  id: text('id').primaryKey().notNull(),\n  title: text('title').notNull(),\n  content: text('content').notNull(),\n  userId: text('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),\n  isPublic: boolean('is_public').default(false).notNull(),\n  teamId: text('team_id'),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull(),\n});\n\nexport const tags = pgTable('tags', {\n  id: text('id').primaryKey().notNull(),\n  name: text('name').notNull(),\n  color: text('color').notNull(),\n  userId: text('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull(),\n});\n\nexport const tagsOnMemos = pgTable('tags_on_memos', {\n  memoId: text('memo_id').notNull().references(() => memos.id, { onDelete: 'cascade' }),\n  tagId: text('tag_id').notNull().references(() => tags.id, { onDelete: 'cascade' }),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n}, (t) => ({\n  pk: primaryKey({ columns: [t.memoId, t.tagId] }),\n}));\n\nexport const aiSuggestions = pgTable('ai_suggestions', {\n  id: text('id').primaryKey().notNull(),\n  memoId: text('memo_id').notNull().references(() => memos.id, { onDelete: 'cascade' }),\n  type: text('type').notNull(),\n  content: text('content').notNull(),\n  applied: boolean('applied').default(false).notNull(),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n});\n\nexport const teams = pgTable('teams', {\n  id: text('id').primaryKey().notNull(),\n  name: text('name').notNull(),\n  description: text('description'),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n  updatedAt: timestamp('updated_at').defaultNow().notNull(),\n});\n\nexport const teamMembers = pgTable('team_members', {\n  id: text('id').primaryKey().notNull(),\n  teamId: text('team_id').notNull().references(() => teams.id, { onDelete: 'cascade' }),\n  userId: text('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),\n  role: text('role').notNull(),\n  joinedAt: timestamp('joined_at').defaultNow().notNull(),\n});\n\n// 관계 정의\nexport const usersRelations = relations(users, ({ many }) => ({\n  memos: many(memos),\n  tags: many(tags),\n  teamMembers: many(teamMembers),\n}));\n\nexport const memosRelations = relations(memos, ({ one, many }) => ({\n  user: one(users, {\n    fields: [memos.userId],\n    references: [users.id],\n  }),\n  team: one(teams, {\n    fields: [memos.teamId],\n    references: [teams.id],\n  }),\n  tags: many(tagsOnMemos),\n  aiSuggestions: many(aiSuggestions),\n}));\n\nexport const tagsRelations = relations(tags, ({ one, many }) => ({\n  user: one(users, {\n    fields: [tags.userId],\n    references: [users.id],\n  }),\n  memos: many(tagsOnMemos),\n}));\n\nexport const tagsOnMemosRelations = relations(tagsOnMemos, ({ one }) => ({\n  memo: one(memos, {\n    fields: [tagsOnMemos.memoId],\n    references: [memos.id],\n  }),\n  tag: one(tags, {\n    fields: [tagsOnMemos.tagId],\n    references: [tags.id],\n  }),\n}));\n```\n4. 데이터베이스 마이그레이션 설정: `npm install drizzle-kit`\n5. DrizzleORM 클라이언트 생성 및 싱글톤 패턴 구현:\n```typescript\n// lib/db.ts\nimport { drizzle } from 'drizzle-orm/postgres-js';\nimport { createClient } from '@supabase/supabase-js';\nimport postgres from 'postgres';\nimport * as schema from '../drizzle/schema';\n\n// Supabase 클라이언트 초기화\nexport const supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n);\n\n// PostgreSQL 클라이언트 초기화\nconst connectionString = process.env.DATABASE_URL!;\nconst client = postgres(connectionString);\n\n// DrizzleORM 클라이언트 초기화\nexport const db = drizzle(client, { schema });\n```\n6. 전체 텍스트 검색을 위한 인덱스 설정",
        "testStrategy": "1. 데이터베이스 연결 테스트\n2. DrizzleORM 마이그레이션 검증\n3. 모든 모델에 대한 CRUD 작업 테스트\n4. 관계 쿼리 테스트 (User-Memo, Memo-Tag 등)\n5. 인덱스 성능 테스트\n6. 트랜잭션 및 롤백 테스트",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "사용자 인증 시스템 구현",
        "description": "JWT 기반 인증 시스템을 구현하여 사용자 등록, 로그인, 로그아웃 및 프로필 관리 기능을 제공합니다.",
        "details": "1. NextAuth.js 설치 및 설정: `npm install next-auth@beta`\n2. Supabase Auth 설정 및 NextAuth 연동\n3. 인증 API 라우트 구현:\n   - `/app/api/auth/[...nextauth]/route.ts`: NextAuth 핸들러\n   - `/app/api/auth/register/route.ts`: 회원가입 API\n4. JWT 전략 구성 및 세션 관리:\n```typescript\n// app/api/auth/[...nextauth]/route.ts\nimport NextAuth from 'next-auth'\nimport CredentialsProvider from 'next-auth/providers/credentials'\nimport { compare } from 'bcrypt'\nimport { db } from '@/lib/db'\nimport { users } from '@/drizzle/schema'\nimport { eq } from 'drizzle-orm'\n\nexport const authOptions = {\n  providers: [\n    CredentialsProvider({\n      name: 'Credentials',\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" }\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          return null\n        }\n\n        const user = await db.query.users.findFirst({\n          where: eq(users.email, credentials.email)\n        })\n\n        if (!user || !(await compare(credentials.password, user.password))) {\n          return null\n        }\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name\n        }\n      }\n    })\n  ],\n  session: { strategy: \"jwt\" },\n  callbacks: {\n    async session({ session, token }) {\n      if (token) {\n        session.user.id = token.id\n      }\n      return session\n    },\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id\n      }\n      return token\n    }\n  },\n  pages: {\n    signIn: '/login',\n    signOut: '/',\n    error: '/login'\n  }\n}\n\nconst handler = NextAuth(authOptions)\nexport { handler as GET, handler as POST }\n```\n5. 회원가입 API 구현 (비밀번호 해싱 포함):\n```typescript\n// app/api/auth/register/route.ts\nimport { NextResponse } from 'next/server'\nimport { hash } from 'bcrypt'\nimport { db } from '@/lib/db'\nimport { users } from '@/drizzle/schema'\nimport { eq } from 'drizzle-orm'\nimport { v4 as uuidv4 } from 'uuid'\n\nexport async function POST(req: Request) {\n  try {\n    const { name, email, password } = await req.json()\n    \n    // 이메일 중복 확인\n    const existingUser = await db.query.users.findFirst({\n      where: eq(users.email, email)\n    })\n    \n    if (existingUser) {\n      return NextResponse.json(\n        { error: '이미 사용 중인 이메일입니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 비밀번호 해싱\n    const hashedPassword = await hash(password, 10)\n    \n    // 사용자 생성\n    const userId = uuidv4()\n    await db.insert(users).values({\n      id: userId,\n      name,\n      email,\n      password: hashedPassword\n    })\n    \n    return NextResponse.json(\n      { message: '회원가입이 완료되었습니다.', userId },\n      { status: 201 }\n    )\n  } catch (error) {\n    console.error('회원가입 오류:', error)\n    return NextResponse.json(\n      { error: '회원가입 처리 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n6. 인증 상태 관리를 위한 클라이언트 컴포넌트 구현\n7. 보호된 라우트 구현 (미들웨어 활용)\n8. 사용자 프로필 관리 기능 구현",
        "testStrategy": "1. 회원가입 프로세스 테스트\n2. 로그인/로그아웃 기능 테스트\n3. 비밀번호 해싱 검증\n4. JWT 토큰 생성 및 검증 테스트\n5. 보호된 라우트 접근 제어 테스트\n6. 세션 지속성 테스트\n7. 오류 처리 및 유효성 검사 테스트",
        "priority": "high",
        "dependencies": [
          11,
          12
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "NextAuth.js 및 Supabase Auth 환경 설정",
            "description": "NextAuth.js와 Supabase Auth를 프로젝트에 설치 및 연동하고, 환경 변수와 클라이언트/서버 유틸리티를 구성합니다.",
            "dependencies": [],
            "details": "next-auth, @supabase/supabase-js, @supabase/ssr 등 필수 패키지를 설치하고, .env.local에 Supabase URL 및 키를 설정합니다. 클라이언트/서버용 Supabase 유틸리티 함수를 작성하여 Next.js App Router 환경에서 사용할 수 있도록 준비합니다.",
            "status": "done",
            "testStrategy": "환경 변수 로딩 및 Supabase 연결 테스트, NextAuth.js 초기화 및 기본 인증 플로우 정상 동작 확인"
          },
          {
            "id": 2,
            "title": "인증 API 라우트 및 JWT 전략 구현",
            "description": "NextAuth.js CredentialsProvider 기반 인증 API 라우트와 JWT 세션 전략을 구현합니다.",
            "dependencies": [
              "13.1"
            ],
            "details": "/app/api/auth/[...nextauth]/route.ts에 CredentialsProvider를 활용한 로그인 로직과 JWT 기반 세션 관리, 콜백 함수(session, jwt) 및 커스텀 인증 페이지 경로를 설정합니다.",
            "status": "done",
            "testStrategy": "로그인/로그아웃 플로우 테스트, JWT 토큰 생성 및 세션 정보 검증, 인증 실패/성공 케이스 테스트"
          },
          {
            "id": 3,
            "title": "회원가입 API 및 비밀번호 해싱 구현",
            "description": "회원가입 API 라우트를 구현하고, 비밀번호 해싱 및 이메일 중복 검증 로직을 추가합니다.",
            "dependencies": [
              "13.1"
            ],
            "details": "/app/api/auth/register/route.ts에 bcrypt를 활용한 비밀번호 해싱, 이메일 중복 체크, 신규 사용자 생성 로직을 작성합니다.",
            "status": "done",
            "testStrategy": "회원가입 성공/실패(중복 이메일, 비밀번호 미입력 등) 테스트, 해싱된 비밀번호 저장 여부 검증"
          },
          {
            "id": 4,
            "title": "클라이언트 인증 상태 및 보호 라우트 구현",
            "description": "클라이언트 컴포넌트에서 인증 상태를 관리하고, 미들웨어를 활용해 보호된 라우트 접근 제어를 구현합니다.",
            "dependencies": [
              "13.2"
            ],
            "details": "useSession 등 NextAuth 클라이언트 훅을 활용해 인증 상태를 표시하고, 인증되지 않은 사용자는 로그인 페이지로 리다이렉트하는 미들웨어를 작성합니다.",
            "status": "done",
            "testStrategy": "로그인 상태에 따른 UI 변화 테스트, 보호 라우트 접근 제한 및 리다이렉트 동작 검증"
          },
          {
            "id": 5,
            "title": "사용자 프로필 관리 기능 구현",
            "description": "사용자가 자신의 프로필 정보를 조회 및 수정할 수 있는 API와 UI를 구현합니다.",
            "dependencies": [
              "13.2"
            ],
            "details": "프로필 조회/수정 API 라우트 및 클라이언트 컴포넌트를 작성하고, 인증된 사용자만 접근 가능하도록 보호합니다.",
            "status": "done",
            "testStrategy": "프로필 정보 조회/수정 정상 동작, 인증되지 않은 접근 차단, 입력값 유효성 검사 및 오류 처리 테스트"
          }
        ]
      },
      {
        "id": 14,
        "title": "리치 텍스트 에디터 구현",
        "description": "마크다운 지원, 실시간 자동 저장, 이미지 및 파일 첨부 기능을 갖춘 리치 텍스트 에디터를 구현합니다.",
        "details": "1. 에디터 라이브러리 설치: `npm install @tiptap/react @tiptap/pm @tiptap/starter-kit @tiptap/extension-image @tiptap/extension-placeholder @tiptap/extension-link @tiptap/extension-code-block-lowlight lowlight`\n2. 마크다운 지원 에디터 컴포넌트 구현:\n```typescript\n// components/editor/RichTextEditor.tsx\n'use client'\n\nimport { useEditor, EditorContent } from '@tiptap/react'\nimport StarterKit from '@tiptap/starter-kit'\nimport Image from '@tiptap/extension-image'\nimport Link from '@tiptap/extension-link'\nimport Placeholder from '@tiptap/extension-placeholder'\nimport CodeBlockLowlight from '@tiptap/extension-code-block-lowlight'\nimport { lowlight } from 'lowlight'\nimport { useCallback, useEffect } from 'react'\nimport EditorToolbar from './EditorToolbar'\n\ninterface RichTextEditorProps {\n  content: string\n  onChange: (content: string) => void\n  placeholder?: string\n  autofocus?: boolean\n}\n\nexport default function RichTextEditor({\n  content,\n  onChange,\n  placeholder = '내용을 입력하세요...',\n  autofocus = false,\n}: RichTextEditorProps) {\n  const editor = useEditor({\n    extensions: [\n      StarterKit,\n      Image,\n      Link.configure({\n        openOnClick: false,\n        validate: href => /^https?:\\/\\//.test(href),\n      }),\n      Placeholder.configure({\n        placeholder,\n      }),\n      CodeBlockLowlight.configure({\n        lowlight,\n      }),\n    ],\n    content,\n    autofocus,\n    onUpdate: ({ editor }) => {\n      onChange(editor.getHTML())\n    },\n  })\n\n  // 자동 저장 로직\n  const autoSave = useCallback(() => {\n    if (editor) {\n      const currentContent = editor.getHTML()\n      // 여기서 자동 저장 API 호출\n      console.log('자동 저장:', currentContent)\n    }\n  }, [editor])\n\n  useEffect(() => {\n    const interval = setInterval(autoSave, 5000) // 5초마다 자동 저장\n    return () => clearInterval(interval)\n  }, [autoSave])\n\n  // 이미지 업로드 핸들러\n  const handleImageUpload = useCallback(\n    async (file: File) => {\n      if (!editor) return\n      \n      const formData = new FormData()\n      formData.append('file', file)\n      \n      try {\n        const response = await fetch('/api/upload', {\n          method: 'POST',\n          body: formData,\n        })\n        \n        const data = await response.json()\n        \n        if (data.url) {\n          editor\n            .chain()\n            .focus()\n            .setImage({ src: data.url })\n            .run()\n        }\n      } catch (error) {\n        console.error('이미지 업로드 오류:', error)\n      }\n    },\n    [editor]\n  )\n\n  if (!editor) {\n    return null\n  }\n\n  return (\n    <div className=\"border rounded-lg overflow-hidden\">\n      <EditorToolbar editor={editor} onImageUpload={handleImageUpload} />\n      <EditorContent editor={editor} className=\"p-4 min-h-[300px] prose max-w-none\" />\n    </div>\n  )\n}\n```\n3. 에디터 툴바 컴포넌트 구현\n4. 이미지 및 파일 업로드 API 구현 (Supabase Storage 연동)\n5. 마크다운 변환 기능 구현\n6. 자동 저장 기능 구현 (디바운싱 적용)\n7. 에디터 상태 관리 및 복원 기능",
        "testStrategy": "1. 에디터 기본 기능 테스트 (텍스트 입력, 서식 적용)\n2. 마크다운 변환 정확성 테스트\n3. 이미지 업로드 및 표시 테스트\n4. 자동 저장 기능 테스트\n5. 다양한 브라우저 호환성 테스트\n6. 모바일 환경 반응형 테스트\n7. 에디터 상태 복원 테스트",
        "priority": "high",
        "dependencies": [
          11,
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "메모 CRUD 기능 구현",
        "description": "메모 생성, 조회, 수정, 삭제 기능을 구현하고 메모 목록 페이지와 상세 페이지를 개발합니다.",
        "details": "1. 메모 관련 API 엔드포인트 구현:\n```typescript\n// app/api/memos/route.ts - 메모 생성 및 목록 조회\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { db } from '@/lib/db'\nimport { memos, tagsOnMemos, tags } from '@/drizzle/schema'\nimport { authOptions } from '../auth/[...nextauth]/route'\nimport { eq, and, like, or, desc, sql } from 'drizzle-orm'\nimport { v4 as uuidv4 } from 'uuid'\n\n// 메모 목록 조회\nexport async function GET(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n\n    const { searchParams } = new URL(req.url)\n    const limit = parseInt(searchParams.get('limit') || '10')\n    const page = parseInt(searchParams.get('page') || '1')\n    const search = searchParams.get('search') || ''\n    const tagId = searchParams.get('tagId')\n\n    const skip = (page - 1) * limit\n    \n    // 검색 조건 구성\n    let query = db.select().from(memos).where(eq(memos.userId, session.user.id))\n    \n    if (search) {\n      query = query.where(\n        or(\n          like(memos.title, `%${search}%`),\n          like(memos.content, `%${search}%`)\n        )\n      )\n    }\n    \n    if (tagId) {\n      query = query.innerJoin(\n        tagsOnMemos,\n        and(\n          eq(tagsOnMemos.memoId, memos.id),\n          eq(tagsOnMemos.tagId, tagId)\n        )\n      )\n    }\n    \n    // 메모 조회\n    const memosData = await query\n      .orderBy(desc(memos.updatedAt))\n      .limit(limit)\n      .offset(skip)\n    \n    // 총 개수 조회\n    const countQuery = db\n      .select({ count: sql<number>`count(*)` })\n      .from(memos)\n      .where(eq(memos.userId, session.user.id))\n    \n    if (search) {\n      countQuery.where(\n        or(\n          like(memos.title, `%${search}%`),\n          like(memos.content, `%${search}%`)\n        )\n      )\n    }\n    \n    if (tagId) {\n      countQuery.innerJoin(\n        tagsOnMemos,\n        and(\n          eq(tagsOnMemos.memoId, memos.id),\n          eq(tagsOnMemos.tagId, tagId)\n        )\n      )\n    }\n    \n    const [{ count }] = await countQuery\n    \n    // 메모에 연결된 태그 조회\n    const memosWithTags = await Promise.all(\n      memosData.map(async (memo) => {\n        const tagsData = await db\n          .select()\n          .from(tags)\n          .innerJoin(\n            tagsOnMemos,\n            and(\n              eq(tagsOnMemos.tagId, tags.id),\n              eq(tagsOnMemos.memoId, memo.id)\n            )\n          )\n        \n        return {\n          ...memo,\n          tags: tagsData.map(({ tags }) => tags),\n        }\n      })\n    )\n    \n    return NextResponse.json({\n      memos: memosWithTags,\n      pagination: {\n        total: count,\n        pages: Math.ceil(count / limit),\n        page,\n        limit,\n      },\n    })\n  } catch (error) {\n    console.error('메모 목록 조회 오류:', error)\n    return NextResponse.json(\n      { error: '메모 목록을 불러오는 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n\n// 메모 생성\nexport async function POST(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const { title, content, isPublic = false, tagIds = [] } = await req.json()\n    \n    if (!title || !content) {\n      return NextResponse.json(\n        { error: '제목과 내용은 필수 입력 항목입니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 트랜잭션으로 메모 및 태그 관계 생성\n    const memoId = uuidv4()\n    \n    await db.transaction(async (tx) => {\n      // 메모 생성\n      await tx.insert(memos).values({\n        id: memoId,\n        title,\n        content,\n        isPublic,\n        userId: session.user.id,\n      })\n      \n      // 태그 연결\n      if (tagIds.length > 0) {\n        await Promise.all(\n          tagIds.map(tagId =>\n            tx.insert(tagsOnMemos).values({\n              memoId,\n              tagId,\n            })\n          )\n        )\n      }\n    })\n    \n    const newMemo = await db.query.memos.findFirst({\n      where: eq(memos.id, memoId)\n    })\n    \n    return NextResponse.json(newMemo, { status: 201 })\n  } catch (error) {\n    console.error('메모 생성 오류:', error)\n    return NextResponse.json(\n      { error: '메모 생성 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n2. 메모 상세, 수정, 삭제 API 구현 (`/app/api/memos/[id]/route.ts`)\n3. 메모 목록 페이지 구현 (`/app/memos/page.tsx`)\n4. 메모 상세 페이지 구현 (`/app/memos/[id]/page.tsx`)\n5. 메모 생성/편집 페이지 구현 (`/app/memos/new/page.tsx`, `/app/memos/[id]/edit/page.tsx`)\n6. 메모 컴포넌트 구현 (목록 아이템, 상세 뷰)\n7. 페이지네이션 및 정렬 기능 구현\n8. 실시간 자동 저장 기능 구현",
        "testStrategy": "1. 메모 CRUD 작업 단위 테스트\n2. API 엔드포인트 통합 테스트\n3. 페이지네이션 및 정렬 기능 테스트\n4. 권한 검사 테스트 (본인 메모만 수정/삭제 가능)\n5. 실시간 자동 저장 기능 테스트\n6. 오류 처리 및 예외 상황 테스트\n7. UI 렌더링 및 사용자 인터랙션 테스트",
        "priority": "high",
        "dependencies": [
          11,
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Anthropic Claude API 연동 및 AI 분석 기능 구현",
        "description": "Anthropic Claude API를 연동하여 메모 내용을 분석하고 문법, 스타일, 구조 개선 제안 및 핵심 포인트 추출 기능을 구현합니다.",
        "details": "1. Anthropic Claude API 설정 및 클라이언트 구현:\n```typescript\n// lib/claude.ts\nimport Anthropic from '@anthropic-ai/sdk';\n\nconst anthropic = new Anthropic({\n  apiKey: process.env.ANTHROPIC_API_KEY,\n});\n\nexport default anthropic;\n```\n2. AI 분석 API 엔드포인트 구현:\n```typescript\n// app/api/ai/analyze/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../../auth/[...nextauth]/route'\nimport anthropic from '@/lib/claude'\nimport { db } from '@/lib/db'\nimport { memos, aiSuggestions } from '@/drizzle/schema'\nimport { eq } from 'drizzle-orm'\nimport { v4 as uuidv4 } from 'uuid'\n\nexport async function POST(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const { memoId, type } = await req.json()\n    \n    // 메모 조회 및 권한 확인\n    const memo = await db.query.memos.findFirst({\n      where: eq(memos.id, memoId)\n    })\n    \n    if (!memo) {\n      return NextResponse.json({ error: '메모를 찾을 수 없습니다.' }, { status: 404 })\n    }\n    \n    if (memo.userId !== session.user.id) {\n      return NextResponse.json({ error: '권한이 없습니다.' }, { status: 403 })\n    }\n    \n    // 분석 유형에 따른 프롬프트 구성\n    let prompt = ''\n    switch (type) {\n      case 'grammar':\n        prompt = `다음 텍스트의 문법과 맞춤법을 검토하고 개선 제안을 제공해주세요. 원문을 유지하면서 문법적 오류를 수정해주세요:\\n\\n${memo.content}`\n        break\n      case 'style':\n        prompt = `다음 텍스트의 문체와 표현을 분석하고 더 명확하고 효과적인 표현으로 개선할 수 있는 제안을 제공해주세요:\\n\\n${memo.content}`\n        break\n      case 'structure':\n        prompt = `다음 텍스트의 구조를 분석하고 더 논리적이고 체계적인 구조로 개선할 수 있는 방법을 제안해주세요:\\n\\n${memo.content}`\n        break\n      case 'summary':\n        prompt = `다음 텍스트의 핵심 포인트를 추출하여 간결한 요약을 제공해주세요:\\n\\n${memo.content}`\n        break\n      default:\n        return NextResponse.json({ error: '지원하지 않는 분석 유형입니다.' }, { status: 400 })\n    }\n    \n    // Anthropic Claude API 호출\n    const response = await anthropic.messages.create({\n      model: 'claude-3-opus-20240229',\n      max_tokens: 1000,\n      messages: [\n        { role: 'user', content: prompt }\n      ],\n      system: '당신은 텍스트 분석 및 개선을 돕는 AI 어시스턴트입니다.'\n    })\n    \n    const suggestion = response.content[0].text || '분석 결과를 생성할 수 없습니다.'\n    \n    // AI 제안 저장\n    const suggestionId = uuidv4()\n    await db.insert(aiSuggestions).values({\n      id: suggestionId,\n      memoId,\n      type,\n      content: suggestion,\n      applied: false,\n    })\n    \n    const aiSuggestion = await db.query.aiSuggestions.findFirst({\n      where: eq(aiSuggestions.id, suggestionId)\n    })\n    \n    return NextResponse.json(aiSuggestion)\n  } catch (error) {\n    console.error('AI 분석 오류:', error)\n    return NextResponse.json(\n      { error: 'AI 분석 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n3. AI 제안 적용 API 구현 (`/app/api/memos/[id]/ai-suggestions/[suggestionId]/apply/route.ts`)\n4. AI 분석 요청 UI 컴포넌트 구현\n5. AI 제안 표시 및 적용 UI 구현\n6. 캐싱 전략 구현 (비용 최적화)\n7. 오류 처리 및 재시도 로직 구현\n8. 사용량 제한 및 모니터링 기능 구현",
        "testStrategy": "1. Anthropic Claude API 연동 테스트\n2. 다양한 분석 유형별 결과 품질 테스트\n3. 오류 처리 및 예외 상황 테스트\n4. 캐싱 효과 검증\n5. 사용량 제한 기능 테스트\n6. 성능 및 응답 시간 측정\n7. UI 인터랙션 및 사용자 경험 테스트",
        "priority": "high",
        "dependencies": [
          11,
          12,
          13,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "태그 시스템 구현",
        "description": "메모 분류를 위한 태그 생성, 관리, 색상 지정 기능과 태그 기반 필터링 시스템을 구현합니다.",
        "details": "1. 태그 관련 API 엔드포인트 구현:\n```typescript\n// app/api/tags/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../auth/[...nextauth]/route'\nimport { db } from '@/lib/db'\nimport { tags } from '@/drizzle/schema'\nimport { eq, asc } from 'drizzle-orm'\nimport { v4 as uuidv4 } from 'uuid'\n\n// 태그 목록 조회\nexport async function GET(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const tagsData = await db\n      .select()\n      .from(tags)\n      .where(eq(tags.userId, session.user.id))\n      .orderBy(asc(tags.name))\n    \n    return NextResponse.json(tagsData)\n  } catch (error) {\n    console.error('태그 목록 조회 오류:', error)\n    return NextResponse.json(\n      { error: '태그 목록을 불러오는 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n\n// 태그 생성\nexport async function POST(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const { name, color = '#3b82f6' } = await req.json()\n    \n    if (!name) {\n      return NextResponse.json(\n        { error: '태그 이름은 필수 입력 항목입니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 중복 태그 확인\n    const existingTag = await db.query.tags.findFirst({\n      where: and(\n        eq(tags.name, name),\n        eq(tags.userId, session.user.id)\n      )\n    })\n    \n    if (existingTag) {\n      return NextResponse.json(\n        { error: '이미 동일한 이름의 태그가 존재합니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 태그 생성\n    const tagId = uuidv4()\n    await db.insert(tags).values({\n      id: tagId,\n      name,\n      color,\n      userId: session.user.id,\n    })\n    \n    const newTag = await db.query.tags.findFirst({\n      where: eq(tags.id, tagId)\n    })\n    \n    return NextResponse.json(newTag, { status: 201 })\n  } catch (error) {\n    console.error('태그 생성 오류:', error)\n    return NextResponse.json(\n      { error: '태그 생성 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n2. 태그 수정 및 삭제 API 구현 (`/app/api/tags/[id]/route.ts`)\n3. 태그별 메모 조회 API 구현 (`/app/api/tags/[id]/memos/route.ts`)\n4. 태그 관리 UI 컴포넌트 구현\n5. 태그 선택 및 필터링 UI 구현\n6. 태그 색상 선택 기능 구현\n7. 태그 통계 및 사용 빈도 분석 기능 구현",
        "testStrategy": "1. 태그 CRUD 작업 단위 테스트\n2. API 엔드포인트 통합 테스트\n3. 태그 기반 필터링 기능 테스트\n4. 태그 색상 적용 테스트\n5. 중복 태그 처리 테스트\n6. 태그 통계 계산 정확성 테스트\n7. UI 렌더링 및 사용자 인터랙션 테스트",
        "priority": "medium",
        "dependencies": [
          11,
          12,
          13,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "고급 검색 시스템 구현",
        "description": "전체 텍스트 검색, 태그 기반 필터링, 날짜 범위 검색, AI 기반 의미 검색 등 고급 검색 기능을 구현합니다.",
        "details": "1. 고급 검색 API 엔드포인트 구현:\n```typescript\n// app/api/memos/search/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../../auth/[...nextauth]/route'\nimport { db } from '@/lib/db'\nimport { memos, tagsOnMemos } from '@/drizzle/schema'\nimport { eq, and, like, or, gte, lte, desc, sql, inArray } from 'drizzle-orm'\n\nexport async function GET(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const { searchParams } = new URL(req.url)\n    const query = searchParams.get('q') || ''\n    const tagIds = searchParams.getAll('tagId')\n    const startDate = searchParams.get('startDate')\n    const endDate = searchParams.get('endDate')\n    const limit = parseInt(searchParams.get('limit') || '10')\n    const page = parseInt(searchParams.get('page') || '1')\n    const skip = (page - 1) * limit\n    \n    // 검색 조건 구성\n    let dbQuery = db.select().from(memos).where(eq(memos.userId, session.user.id))\n    \n    // 텍스트 검색\n    if (query) {\n      dbQuery = dbQuery.where(\n        or(\n          like(memos.title, `%${query}%`),\n          like(memos.content, `%${query}%`)\n        )\n      )\n    }\n    \n    // 태그 필터링\n    if (tagIds.length > 0) {\n      const subquery = db\n        .select({ memoId: tagsOnMemos.memoId })\n        .from(tagsOnMemos)\n        .where(inArray(tagsOnMemos.tagId, tagIds))\n        .groupBy(tagsOnMemos.memoId)\n        .having({ count: sql`count(*)` }, gte(sql`count(*)`, tagIds.length))\n      \n      dbQuery = dbQuery.where(\n        inArray(\n          memos.id,\n          subquery.map(row => row.memoId)\n        )\n      )\n    }\n    \n    // 날짜 범위 필터링\n    if (startDate) {\n      dbQuery = dbQuery.where(gte(memos.createdAt, new Date(startDate)))\n    }\n    \n    if (endDate) {\n      dbQuery = dbQuery.where(lte(memos.createdAt, new Date(endDate)))\n    }\n    \n    // 메모 검색\n    const memosData = await dbQuery\n      .orderBy(desc(memos.updatedAt))\n      .limit(limit)\n      .offset(skip)\n    \n    // 총 개수 조회\n    const countQuery = db\n      .select({ count: sql<number>`count(*)` })\n      .from(memos)\n      .where(eq(memos.userId, session.user.id))\n    \n    if (query) {\n      countQuery.where(\n        or(\n          like(memos.title, `%${query}%`),\n          like(memos.content, `%${query}%`)\n        )\n      )\n    }\n    \n    // 태그 필터링 (카운트 쿼리)\n    if (tagIds.length > 0) {\n      const subquery = db\n        .select({ memoId: tagsOnMemos.memoId })\n        .from(tagsOnMemos)\n        .where(inArray(tagsOnMemos.tagId, tagIds))\n        .groupBy(tagsOnMemos.memoId)\n        .having({ count: sql`count(*)` }, gte(sql`count(*)`, tagIds.length))\n      \n      countQuery.where(\n        inArray(\n          memos.id,\n          subquery.map(row => row.memoId)\n        )\n      )\n    }\n    \n    // 날짜 범위 필터링 (카운트 쿼리)\n    if (startDate) {\n      countQuery.where(gte(memos.createdAt, new Date(startDate)))\n    }\n    \n    if (endDate) {\n      countQuery.where(lte(memos.createdAt, new Date(endDate)))\n    }\n    \n    const [{ count }] = await countQuery\n    \n    // 메모에 연결된 태그 조회\n    const memosWithTags = await Promise.all(\n      memosData.map(async (memo) => {\n        const tagsData = await db\n          .select()\n          .from(tags)\n          .innerJoin(\n            tagsOnMemos,\n            and(\n              eq(tagsOnMemos.tagId, tags.id),\n              eq(tagsOnMemos.memoId, memo.id)\n            )\n          )\n        \n        return {\n          ...memo,\n          tags: tagsData.map(({ tags }) => tags),\n        }\n      })\n    )\n    \n    return NextResponse.json({\n      memos: memosWithTags,\n      pagination: {\n        total: count,\n        pages: Math.ceil(count / limit),\n        page,\n        limit,\n      },\n    })\n  } catch (error) {\n    console.error('메모 검색 오류:', error)\n    return NextResponse.json(\n      { error: '메모 검색 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n2. AI 기반 의미 검색 구현 (Anthropic Claude 임베딩 활용):\n```typescript\n// app/api/memos/semantic-search/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../../auth/[...nextauth]/route'\nimport { db } from '@/lib/db'\nimport { memos } from '@/drizzle/schema'\nimport { eq } from 'drizzle-orm'\nimport anthropic from '@/lib/claude'\n\nexport async function GET(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const { searchParams } = new URL(req.url)\n    const query = searchParams.get('q')\n    \n    if (!query) {\n      return NextResponse.json(\n        { error: '검색어를 입력해주세요.' },\n        { status: 400 }\n      )\n    }\n    \n    // 사용자의 모든 메모 가져오기\n    const userMemos = await db\n      .select({\n        id: memos.id,\n        title: memos.title,\n        content: memos.content,\n        updatedAt: memos.updatedAt,\n      })\n      .from(memos)\n      .where(eq(memos.userId, session.user.id))\n    \n    // Claude를 사용하여 의미 검색 수행\n    const response = await anthropic.messages.create({\n      model: 'claude-3-opus-20240229',\n      max_tokens: 1000,\n      messages: [\n        { \n          role: 'user', \n          content: `다음은 사용자의 메모 목록입니다. 검색어 \"${query}\"와 의미적으로 가장 관련성이 높은 메모를 찾아주세요. 각 메모에 대해 관련성 점수(0-100)를 매겨서 JSON 형식으로 반환해주세요. 메모 목록:\\n\\n${userMemos.map(memo => `ID: ${memo.id}\\n제목: ${memo.title}\\n내용: ${memo.content}\\n---\\n`).join('\\n')}` \n        }\n      ],\n      system: '당신은 텍스트 검색 및 관련성 평가를 돕는 AI 어시스턴트입니다. 사용자의 검색어와 메모 내용의 의미적 관련성을 평가하여 JSON 형식으로 결과를 반환해주세요.',\n      response_format: { type: 'json_object' }\n    })\n    \n    // Claude 응답 파싱\n    const resultText = response.content[0].text\n    const results = JSON.parse(resultText)\n    \n    // 결과 정렬 및 반환\n    const sortedResults = Object.entries(results)\n      .map(([id, score]) => ({\n        memo: userMemos.find(memo => memo.id === id),\n        score: Number(score)\n      }))\n      .filter(item => item.memo) // 유효한 메모만 포함\n      .sort((a, b) => b.score - a.score) // 점수 내림차순 정렬\n      .slice(0, 10) // 상위 10개 결과만 반환\n    \n    return NextResponse.json({\n      results: sortedResults,\n    })\n  } catch (error) {\n    console.error('의미 검색 오류:', error)\n    return NextResponse.json(\n      { error: '의미 검색 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n3. 검색 UI 컴포넌트 구현\n4. 필터 및 정렬 옵션 UI 구현\n5. 검색 결과 하이라이팅 기능 구현\n6. 검색 히스토리 및 추천 검색어 기능 구현\n7. 검색 성능 최적화 (인덱싱, 캐싱)",
        "testStrategy": "1. 다양한 검색 조건 조합 테스트\n2. 검색 결과 정확성 테스트\n3. 태그 필터링 기능 테스트\n4. 날짜 범위 검색 테스트\n5. AI 의미 검색 품질 테스트\n6. 검색 성능 및 응답 시간 측정\n7. 대량 데이터에서의 검색 성능 테스트",
        "priority": "medium",
        "dependencies": [
          11,
          12,
          13,
          15,
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "팀 및 협업 기능 구현",
        "description": "팀 생성, 관리, 멤버 초대 및 권한 관리, 팀 메모 공유 및 협업 기능을 구현합니다.",
        "details": "1. 팀 관련 API 엔드포인트 구현:\n```typescript\n// app/api/teams/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../auth/[...nextauth]/route'\nimport { db } from '@/lib/db'\nimport { teams, teamMembers, users, memos } from '@/drizzle/schema'\nimport { eq, and } from 'drizzle-orm'\nimport { v4 as uuidv4 } from 'uuid'\n\n// 팀 목록 조회\nexport async function GET(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    // 사용자가 속한 팀 조회\n    const userTeams = await db\n      .select()\n      .from(teams)\n      .innerJoin(\n        teamMembers,\n        and(\n          eq(teamMembers.teamId, teams.id),\n          eq(teamMembers.userId, session.user.id)\n        )\n      )\n    \n    // 각 팀의 멤버 및 메모 수 조회\n    const teamsWithDetails = await Promise.all(\n      userTeams.map(async ({ teams: team }) => {\n        // 팀 멤버 조회\n        const members = await db\n          .select({\n            id: teamMembers.id,\n            role: teamMembers.role,\n            joinedAt: teamMembers.joinedAt,\n            user: {\n              id: users.id,\n              name: users.name,\n              email: users.email,\n              avatar: users.avatar,\n            },\n          })\n          .from(teamMembers)\n          .innerJoin(\n            users,\n            eq(teamMembers.userId, users.id)\n          )\n          .where(eq(teamMembers.teamId, team.id))\n        \n        // 팀 메모 수 조회\n        const [{ count }] = await db\n          .select({ count: sql<number>`count(*)` })\n          .from(memos)\n          .where(eq(memos.teamId, team.id))\n        \n        return {\n          ...team,\n          members,\n          memoCount: count,\n        }\n      })\n    )\n    \n    return NextResponse.json(teamsWithDetails)\n  } catch (error) {\n    console.error('팀 목록 조회 오류:', error)\n    return NextResponse.json(\n      { error: '팀 목록을 불러오는 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n\n// 팀 생성\nexport async function POST(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const { name, description = '' } = await req.json()\n    \n    if (!name) {\n      return NextResponse.json(\n        { error: '팀 이름은 필수 입력 항목입니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 트랜잭션으로 팀 및 멤버 생성\n    const teamId = uuidv4()\n    const memberId = uuidv4()\n    \n    await db.transaction(async (tx) => {\n      // 팀 생성\n      await tx.insert(teams).values({\n        id: teamId,\n        name,\n        description,\n      })\n      \n      // 생성자를 팀 소유자로 추가\n      await tx.insert(teamMembers).values({\n        id: memberId,\n        teamId,\n        userId: session.user.id,\n        role: 'owner',\n      })\n    })\n    \n    const newTeam = await db.query.teams.findFirst({\n      where: eq(teams.id, teamId)\n    })\n    \n    return NextResponse.json(newTeam, { status: 201 })\n  } catch (error) {\n    console.error('팀 생성 오류:', error)\n    return NextResponse.json(\n      { error: '팀 생성 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n2. 팀 상세, 수정, 삭제 API 구현 (`/app/api/teams/[id]/route.ts`)\n3. 팀원 관리 API 구현 (`/app/api/teams/[id]/members/route.ts`)\n4. 팀 메모 API 구현 (`/app/api/teams/[id]/memos/route.ts`)\n5. 팀 초대 시스템 구현 (이메일 초대)\n6. 팀 관리 UI 컴포넌트 구현\n7. 팀 메모 공유 및 협업 UI 구현\n8. 권한 기반 접근 제어 구현",
        "testStrategy": "1. 팀 CRUD 작업 단위 테스트\n2. 팀원 초대 및 권한 관리 테스트\n3. 팀 메모 공유 및 접근 권한 테스트\n4. 여러 사용자 간 협업 시나리오 테스트\n5. 권한 기반 접근 제어 테스트\n6. 이메일 초대 기능 테스트\n7. UI 렌더링 및 사용자 인터랙션 테스트",
        "priority": "medium",
        "dependencies": [
          11,
          12,
          13,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "실시간 협업 기능 구현",
        "description": "WebSocket을 활용한 실시간 메모 편집, 변경 사항 추적, 댓글 및 피드백 시스템을 구현합니다.",
        "details": "1. WebSocket 서버 설정 (Socket.io 활용):\n```typescript\n// lib/socket.ts\nimport { Server as HTTPServer } from 'http'\nimport { Server as IOServer } from 'socket.io'\nimport { NextApiRequest } from 'next'\nimport { getToken } from 'next-auth/jwt'\n\nexport const initSocketServer = (httpServer: HTTPServer) => {\n  const io = new IOServer(httpServer, {\n    path: '/api/socketio',\n    cors: {\n      origin: process.env.NEXTAUTH_URL,\n      methods: ['GET', 'POST'],\n      credentials: true,\n    },\n  })\n  \n  // 인증 미들웨어\n  io.use(async (socket, next) => {\n    try {\n      const req = socket.request as NextApiRequest\n      const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET })\n      \n      if (!token) {\n        return next(new Error('인증이 필요합니다.'))\n      }\n      \n      socket.data.user = {\n        id: token.id,\n        name: token.name,\n        email: token.email,\n      }\n      \n      next()\n    } catch (error) {\n      next(new Error('인증 처리 중 오류가 발생했습니다.'))\n    }\n  })\n  \n  // 연결 이벤트 처리\n  io.on('connection', (socket) => {\n    console.log(`사용자 연결됨: ${socket.data.user.id}`)\n    \n    // 메모 룸 참여\n    socket.on('join-memo', (memoId) => {\n      socket.join(`memo:${memoId}`)\n      console.log(`사용자 ${socket.data.user.id}가 메모 ${memoId}에 참여함`)\n      \n      // 참여 알림\n      socket.to(`memo:${memoId}`).emit('user-joined', {\n        userId: socket.data.user.id,\n        userName: socket.data.user.name,\n      })\n    })\n    \n    // 메모 룸 퇴장\n    socket.on('leave-memo', (memoId) => {\n      socket.leave(`memo:${memoId}`)\n      console.log(`사용자 ${socket.data.user.id}가 메모 ${memoId}에서 퇴장함`)\n      \n      // 퇴장 알림\n      socket.to(`memo:${memoId}`).emit('user-left', {\n        userId: socket.data.user.id,\n        userName: socket.data.user.name,\n      })\n    })\n    \n    // 메모 내용 변경\n    socket.on('memo-change', ({ memoId, content, cursorPosition }) => {\n      socket.to(`memo:${memoId}`).emit('memo-updated', {\n        userId: socket.data.user.id,\n        userName: socket.data.user.name,\n        content,\n        cursorPosition,\n        timestamp: new Date(),\n      })\n    })\n    \n    // 댓글 추가\n    socket.on('add-comment', ({ memoId, comment }) => {\n      socket.to(`memo:${memoId}`).emit('new-comment', {\n        userId: socket.data.user.id,\n        userName: socket.data.user.name,\n        comment,\n        timestamp: new Date(),\n      })\n    })\n    \n    // 연결 해제\n    socket.on('disconnect', () => {\n      console.log(`사용자 연결 해제됨: ${socket.data.user.id}`)\n    })\n  })\n  \n  return io\n}\n```\n2. 클라이언트 Socket.io 연결 구현:\n```typescript\n// lib/socketClient.ts\nimport { io, Socket } from 'socket.io-client'\nimport { useEffect, useState } from 'react'\n\nlet socket: Socket | null = null\n\nexport const initSocket = () => {\n  if (!socket) {\n    socket = io(process.env.NEXT_PUBLIC_SITE_URL || '', {\n      path: '/api/socketio',\n      withCredentials: true,\n    })\n  }\n  return socket\n}\n\nexport const useSocket = () => {\n  const [isConnected, setIsConnected] = useState(false)\n  \n  useEffect(() => {\n    const socketInstance = initSocket()\n    \n    const onConnect = () => {\n      setIsConnected(true)\n      console.log('Socket 연결됨')\n    }\n    \n    const onDisconnect = () => {\n      setIsConnected(false)\n      console.log('Socket 연결 해제됨')\n    }\n    \n    socketInstance.on('connect', onConnect)\n    socketInstance.on('disconnect', onDisconnect)\n    \n    if (socketInstance.connected) {\n      setIsConnected(true)\n    }\n    \n    return () => {\n      socketInstance.off('connect', onConnect)\n      socketInstance.off('disconnect', onDisconnect)\n    }\n  }, [])\n  \n  return { socket: socket as Socket, isConnected }\n}\n```\n3. 실시간 협업 에디터 구현 (TipTap + Y.js 활용)\n4. 변경 사항 추적 및 충돌 해결 로직 구현\n5. 실시간 댓글 및 피드백 시스템 구현\n6. 사용자 온라인 상태 표시 기능 구현\n7. 알림 시스템 구현 (실시간 + 이메일)",
        "testStrategy": "1. WebSocket 연결 및 이벤트 처리 테스트\n2. 여러 사용자 동시 편집 시나리오 테스트\n3. 네트워크 지연 및 연결 끊김 상황 테스트\n4. 충돌 해결 로직 테스트\n5. 실시간 알림 전달 테스트\n6. 대규모 동시 접속 성능 테스트\n7. 브라우저 호환성 테스트",
        "priority": "medium",
        "dependencies": [
          11,
          12,
          13,
          15,
          19
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "파일 업로드 및 스토리지 시스템 구현",
        "description": "Supabase Storage를 활용한 이미지 및 파일 업로드, 저장, 관리 시스템을 구현합니다.",
        "details": "1. Supabase Storage 설정 및 클라이언트 구현:\n```typescript\n// lib/storage.ts\nimport { supabase } from '@/lib/db'\nimport { v4 as uuidv4 } from 'uuid'\n\n// 파일 업로드 함수\nexport async function uploadFile(file: Buffer, fileName: string, contentType: string) {\n  // 고유한 파일명 생성\n  const fileExt = fileName.split('.').pop()\n  const fileKey = `uploads/${uuidv4()}.${fileExt}`\n  \n  // Supabase Storage에 업로드\n  const { data, error } = await supabase.storage\n    .from('files')\n    .upload(fileKey, file, {\n      contentType,\n      cacheControl: '3600',\n      upsert: false\n    })\n  \n  if (error) {\n    throw new Error(`파일 업로드 오류: ${error.message}`)\n  }\n  \n  // 공개 URL 생성\n  const { data: { publicUrl } } = supabase.storage\n    .from('files')\n    .getPublicUrl(fileKey)\n  \n  return {\n    url: publicUrl,\n    key: fileKey,\n  }\n}\n\n// 파일 삭제 함수\nexport async function deleteFile(fileKey: string) {\n  const { error } = await supabase.storage\n    .from('files')\n    .remove([fileKey])\n  \n  if (error) {\n    throw new Error(`파일 삭제 오류: ${error.message}`)\n  }\n}\n\n// 서명된 URL 생성 함수 (클라이언트에서 직접 업로드용)\nexport async function getSignedUrl(fileName: string) {\n  const fileExt = fileName.split('.').pop()\n  const fileKey = `uploads/${uuidv4()}.${fileExt}`\n  \n  const { data, error } = await supabase.storage\n    .from('files')\n    .createSignedUploadUrl(fileKey)\n  \n  if (error) {\n    throw new Error(`서명된 URL 생성 오류: ${error.message}`)\n  }\n  \n  // 공개 URL 생성\n  const { data: { publicUrl } } = supabase.storage\n    .from('files')\n    .getPublicUrl(fileKey)\n  \n  return {\n    signedUrl: data.signedUrl,\n    fileKey,\n    url: publicUrl,\n  }\n}\n```\n2. 파일 업로드 API 엔드포인트 구현:\n```typescript\n// app/api/upload/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../auth/[...nextauth]/route'\nimport { uploadFile } from '@/lib/storage'\n\nexport async function POST(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const formData = await req.formData()\n    const file = formData.get('file') as File\n    \n    if (!file) {\n      return NextResponse.json(\n        { error: '파일이 제공되지 않았습니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 파일 크기 제한 (10MB)\n    if (file.size > 10 * 1024 * 1024) {\n      return NextResponse.json(\n        { error: '파일 크기는 10MB를 초과할 수 없습니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 허용된 파일 타입 확인\n    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf']\n    if (!allowedTypes.includes(file.type)) {\n      return NextResponse.json(\n        { error: '지원되지 않는 파일 형식입니다.' },\n        { status: 400 }\n      )\n    }\n    \n    // 파일 버퍼로 변환\n    const buffer = Buffer.from(await file.arrayBuffer())\n    \n    // Supabase Storage에 업로드\n    const result = await uploadFile(buffer, file.name, file.type)\n    \n    return NextResponse.json({\n      url: result.url,\n      key: result.key,\n    })\n  } catch (error) {\n    console.error('파일 업로드 오류:', error)\n    return NextResponse.json(\n      { error: '파일 업로드 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n3. 프리사인드 URL API 구현 (대용량 파일 직접 업로드용)\n4. 파일 삭제 API 구현\n5. 파일 업로드 UI 컴포넌트 구현\n6. 이미지 미리보기 및 갤러리 기능 구현\n7. 파일 형식 및 크기 검증 로직 구현\n8. CDN 설정 및 최적화",
        "testStrategy": "1. 다양한 파일 형식 업로드 테스트\n2. 대용량 파일 업로드 테스트\n3. 파일 삭제 기능 테스트\n4. 권한 검증 테스트\n5. 오류 처리 및 예외 상황 테스트\n6. 업로드 진행률 표시 테스트\n7. CDN 캐싱 및 성능 테스트",
        "priority": "medium",
        "dependencies": [
          11,
          12,
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "대시보드 및 분석 기능 구현",
        "description": "사용자 활동, 메모 통계, AI 활용도 등을 시각화하는 대시보드 및 분석 기능을 구현합니다.",
        "details": "1. 대시보드 데이터 API 엔드포인트 구현:\n```typescript\n// app/api/dashboard/stats/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../../auth/[...nextauth]/route'\nimport { db } from '@/lib/db'\nimport { memos, tags, tagsOnMemos, aiSuggestions } from '@/drizzle/schema'\nimport { eq, gte, count, sql, desc } from 'drizzle-orm'\n\nexport async function GET(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    // 기간 파라미터 (기본: 30일)\n    const { searchParams } = new URL(req.url)\n    const days = parseInt(searchParams.get('days') || '30')\n    const startDate = new Date()\n    startDate.setDate(startDate.getDate() - days)\n    \n    // 병렬로 여러 통계 데이터 조회\n    const [totalMemosResult, recentMemosResult, totalTagsResult, aiSuggestionsResult, popularTagsResult, activityByDayResult] = await Promise.all([\n      // 총 메모 수\n      db\n        .select({ count: count() })\n        .from(memos)\n        .where(eq(memos.userId, session.user.id)),\n      \n      // 최근 메모 수\n      db\n        .select({ count: count() })\n        .from(memos)\n        .where(\n          and(\n            eq(memos.userId, session.user.id),\n            gte(memos.createdAt, startDate)\n          )\n        ),\n      \n      // 총 태그 수\n      db\n        .select({ count: count() })\n        .from(tags)\n        .where(eq(tags.userId, session.user.id)),\n      \n      // AI 제안 통계\n      db\n        .select({\n          type: aiSuggestions.type,\n          count: count(),\n        })\n        .from(aiSuggestions)\n        .innerJoin(\n          memos,\n          and(\n            eq(aiSuggestions.memoId, memos.id),\n            eq(memos.userId, session.user.id),\n            gte(aiSuggestions.createdAt, startDate)\n          )\n        )\n        .groupBy(aiSuggestions.type),\n      \n      // 인기 태그\n      db\n        .select({\n          id: tags.id,\n          name: tags.name,\n          color: tags.color,\n          count: count(tagsOnMemos.memoId),\n        })\n        .from(tags)\n        .leftJoin(\n          tagsOnMemos,\n          eq(tagsOnMemos.tagId, tags.id)\n        )\n        .where(eq(tags.userId, session.user.id))\n        .groupBy(tags.id, tags.name, tags.color)\n        .orderBy(desc(sql`count(${tagsOnMemos.memoId})`))\n        .limit(5),\n      \n      // 일별 활동\n      db\n        .select({\n          date: sql`date_trunc('day', ${memos.createdAt})::date`,\n          count: count(),\n        })\n        .from(memos)\n        .where(\n          and(\n            eq(memos.userId, session.user.id),\n            gte(memos.createdAt, startDate)\n          )\n        )\n        .groupBy(sql`date_trunc('day', ${memos.createdAt})::date`),\n    ])\n    \n    // 결과 추출\n    const totalMemos = totalMemosResult[0]?.count || 0\n    const recentMemos = recentMemosResult[0]?.count || 0\n    const totalTags = totalTagsResult[0]?.count || 0\n    \n    // 일별 활동 데이터 가공\n    const activityMap = new Map()\n    const today = new Date()\n    \n    // 모든 날짜 초기화 (0으로)\n    for (let i = 0; i < days; i++) {\n      const date = new Date(today)\n      date.setDate(date.getDate() - i)\n      const dateStr = date.toISOString().split('T')[0]\n      activityMap.set(dateStr, 0)\n    }\n    \n    // 실제 활동 데이터 채우기\n    activityByDayResult.forEach(day => {\n      const dateStr = day.date.toISOString().split('T')[0]\n      activityMap.set(dateStr, day.count)\n    })\n    \n    // AI 제안 데이터 가공\n    const aiSuggestionsByType = {}\n    aiSuggestionsResult.forEach(item => {\n      aiSuggestionsByType[item.type] = item.count\n    })\n    \n    // 응답 데이터 구성\n    const stats = {\n      totalMemos,\n      recentMemos,\n      totalTags,\n      aiSuggestions: aiSuggestionsByType,\n      popularTags: popularTagsResult,\n      activityByDay: Array.from(activityMap.entries()).map(([date, count]) => ({\n        date,\n        count,\n      })).sort((a, b) => a.date.localeCompare(b.date)),\n    }\n    \n    return NextResponse.json(stats)\n  } catch (error) {\n    console.error('대시보드 통계 조회 오류:', error)\n    return NextResponse.json(\n      { error: '통계 데이터를 불러오는 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n2. 팀 활동 분석 API 구현\n3. 데이터 시각화 컴포넌트 구현 (Chart.js 활용)\n4. 대시보드 페이지 구현\n5. 사용자 활동 추적 시스템 구현\n6. 메모 사용 패턴 분석 기능 구현\n7. AI 활용도 분석 기능 구현",
        "testStrategy": "1. 통계 데이터 계산 정확성 테스트\n2. 다양한 기간 설정에 따른 데이터 변화 테스트\n3. 차트 렌더링 및 반응형 디자인 테스트\n4. 대량 데이터에서의 성능 테스트\n5. 데이터 필터링 및 정렬 기능 테스트\n6. 사용자 활동 추적 정확성 테스트\n7. UI 렌더링 및 사용자 인터랙션 테스트",
        "priority": "low",
        "dependencies": [
          11,
          12,
          13,
          15,
          16,
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "알림 시스템 구현",
        "description": "실시간 알림, 이메일 알림, 푸시 알림 등 다양한 알림 시스템을 구현합니다.",
        "details": "1. 알림 모델 및 API 구현:\n```typescript\n// drizzle/schema.ts에 추가\nexport const notifications = pgTable('notifications', {\n  id: text('id').primaryKey().notNull(),\n  userId: text('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),\n  type: text('type').notNull(), // 'memo_comment', 'team_invite', 'ai_suggestion', 등\n  title: text('title').notNull(),\n  content: text('content').notNull(),\n  link: text('link'),\n  read: boolean('read').default(false).notNull(),\n  createdAt: timestamp('created_at').defaultNow().notNull(),\n});\n\nexport const notificationsRelations = relations(notifications, ({ one }) => ({\n  user: one(users, {\n    fields: [notifications.userId],\n    references: [users.id],\n  }),\n}));\n```\n\n```typescript\n// app/api/notifications/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../auth/[...nextauth]/route'\nimport { db } from '@/lib/db'\nimport { notifications } from '@/drizzle/schema'\nimport { eq, desc, count, and } from 'drizzle-orm'\n\n// 알림 목록 조회\nexport async function GET(req: Request) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const { searchParams } = new URL(req.url)\n    const limit = parseInt(searchParams.get('limit') || '20')\n    const page = parseInt(searchParams.get('page') || '1')\n    const unreadOnly = searchParams.get('unreadOnly') === 'true'\n    \n    const skip = (page - 1) * limit\n    \n    // 검색 조건 구성\n    let query = db\n      .select()\n      .from(notifications)\n      .where(eq(notifications.userId, session.user.id))\n    \n    if (unreadOnly) {\n      query = query.where(eq(notifications.read, false))\n    }\n    \n    // 알림 조회\n    const notificationsData = await query\n      .orderBy(desc(notifications.createdAt))\n      .limit(limit)\n      .offset(skip)\n    \n    // 총 개수 조회\n    const [{ total }] = await db\n      .select({ total: count() })\n      .from(notifications)\n      .where(eq(notifications.userId, session.user.id))\n    \n    // 읽지 않은 알림 수 조회\n    const [{ unreadCount }] = await db\n      .select({ unreadCount: count() })\n      .from(notifications)\n      .where(\n        and(\n          eq(notifications.userId, session.user.id),\n          eq(notifications.read, false)\n        )\n      )\n    \n    return NextResponse.json({\n      notifications: notificationsData,\n      pagination: {\n        total,\n        pages: Math.ceil(total / limit),\n        page,\n        limit,\n      },\n      unreadCount,\n    })\n  } catch (error) {\n    console.error('알림 목록 조회 오류:', error)\n    return NextResponse.json(\n      { error: '알림 목록을 불러오는 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n2. 알림 읽음 표시 API 구현\n3. 알림 생성 유틸리티 함수 구현:\n```typescript\n// lib/notifications.ts\nimport { db } from './db'\nimport { notifications } from '@/drizzle/schema'\nimport { sendEmail } from './email'\nimport { v4 as uuidv4 } from 'uuid'\n\ntype NotificationType = 'memo_comment' | 'team_invite' | 'ai_suggestion' | 'memo_share'\n\ninterface CreateNotificationParams {\n  userId: string\n  type: NotificationType\n  title: string\n  content: string\n  link?: string\n  emailNotification?: boolean\n}\n\nexport async function createNotification({\n  userId,\n  type,\n  title,\n  content,\n  link,\n  emailNotification = false,\n}: CreateNotificationParams) {\n  // 데이터베이스에 알림 생성\n  const notificationId = uuidv4()\n  await db.insert(notifications).values({\n    id: notificationId,\n    userId,\n    type,\n    title,\n    content,\n    link,\n    read: false,\n  })\n  \n  const [notification] = await db\n    .select()\n    .from(notifications)\n    .where(eq(notifications.id, notificationId))\n    .innerJoin(users, eq(notifications.userId, users.id))\n  \n  // 실시간 알림 전송 (Socket.io 활용)\n  if (global.io) {\n    global.io.to(`user:${userId}`).emit('new-notification', notification)\n  }\n  \n  // 이메일 알림 전송\n  if (emailNotification && notification.users.email) {\n    await sendEmail({\n      to: notification.users.email,\n      subject: title,\n      text: content,\n      html: `<p>${content}</p>${link ? `<p><a href=\"${link}\">자세히 보기</a></p>` : ''}`,\n    })\n  }\n  \n  return notification\n}\n```\n4. 실시간 알림 시스템 구현 (Socket.io 활용)\n5. 이메일 알림 시스템 구현 (Nodemailer 활용)\n6. 푸시 알림 시스템 구현 (웹 푸시 API 활용)\n7. 알림 설정 및 관리 UI 구현\n8. 알림 센터 UI 구현",
        "testStrategy": "1. 알림 생성 및 조회 기능 테스트\n2. 실시간 알림 전송 테스트\n3. 이메일 알림 전송 테스트\n4. 푸시 알림 전송 테스트\n5. 알림 읽음 표시 기능 테스트\n6. 알림 설정 저장 및 적용 테스트\n7. 다양한 알림 유형 및 시나리오 테스트",
        "priority": "low",
        "dependencies": [
          11,
          12,
          13,
          15,
          19,
          20
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "내보내기 및 백업 기능 구현",
        "description": "메모를 다양한 형식(PDF, Markdown, Word)으로 내보내기 및 자동 백업 기능을 구현합니다.",
        "details": "1. PDF 내보내기 기능 구현 (react-pdf 활용):\n```typescript\n// app/api/memos/[id]/export/pdf/route.ts\nimport { NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '../../../../auth/[...nextauth]/route'\nimport { db } from '@/lib/db'\nimport { memos, users, tagsOnMemos, tags } from '@/drizzle/schema'\nimport { eq, and } from 'drizzle-orm'\nimport PDFDocument from 'pdfkit'\n\nexport async function GET(req: Request, { params }: { params: { id: string } }) {\n  try {\n    const session = await getServerSession(authOptions)\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: '인증이 필요합니다.' }, { status: 401 })\n    }\n    \n    const memoId = params.id\n    \n    // 메모 조회\n    const memo = await db.query.memos.findFirst({\n      where: eq(memos.id, memoId),\n      with: {\n        user: true,\n      },\n    })\n    \n    if (!memo) {\n      return NextResponse.json({ error: '메모를 찾을 수 없습니다.' }, { status: 404 })\n    }\n    \n    if (memo.userId !== session.user.id && !memo.isPublic) {\n      return NextResponse.json({ error: '권한이 없습니다.' }, { status: 403 })\n    }\n    \n    // 메모에 연결된 태그 조회\n    const tagsData = await db\n      .select()\n      .from(tags)\n      .innerJoin(\n        tagsOnMemos,\n        and(\n          eq(tagsOnMemos.tagId, tags.id),\n          eq(tagsOnMemos.memoId, memoId)\n        )\n      )\n    \n    // PDF 생성\n    const pdfBuffer = await new Promise<Buffer>((resolve) => {\n      const doc = new PDFDocument({\n        margin: 50,\n        size: 'A4',\n      })\n      \n      const chunks: Buffer[] = []\n      doc.on('data', (chunk) => chunks.push(chunk))\n      doc.on('end', () => resolve(Buffer.concat(chunks)))\n      \n      // PDF 내용 작성\n      doc.fontSize(24).text(memo.title, { align: 'center' })\n      doc.moveDown()\n      \n      // 메타 정보\n      doc.fontSize(10).text(`작성자: ${memo.user.name}`, { align: 'left' })\n      doc.fontSize(10).text(`작성일: ${memo.createdAt.toLocaleDateString('ko-KR')}`, { align: 'left' })\n      \n      // 태그\n      if (tagsData.length > 0) {\n        const tagNames = tagsData.map(t => t.tags.name).join(', ')\n        doc.fontSize(10).text(`태그: ${tagNames}`, { align: 'left' })\n      }\n      \n      doc.moveDown()\n      doc.moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke()\n      doc.moveDown()\n      \n      // 본문 내용 (HTML을 텍스트로 변환하여 삽입)\n      const contentText = memo.content.replace(/<[^>]*>/g, '')\n      doc.fontSize(12).text(contentText, {\n        align: 'left',\n        lineGap: 5,\n      })\n      \n      doc.end()\n    })\n    \n    // 응답 헤더 설정\n    const headers = new Headers()\n    headers.set('Content-Type', 'application/pdf')\n    headers.set('Content-Disposition', `attachment; filename=\"${encodeURIComponent(memo.title)}.pdf\"`)\n    \n    return new NextResponse(pdfBuffer, {\n      status: 200,\n      headers,\n    })\n  } catch (error) {\n    console.error('PDF 내보내기 오류:', error)\n    return NextResponse.json(\n      { error: 'PDF 생성 중 오류가 발생했습니다.' },\n      { status: 500 }\n    )\n  }\n}\n```\n2. Markdown 내보내기 기능 구현\n3. Word(DOCX) 내보내기 기능 구현 (docx 라이브러리 활용)\n4. 메모 백업 API 구현 (전체 메모 JSON/CSV 내보내기)\n5. 자동 백업 스케줄링 구현 (Vercel Cron 활용)\n6. 백업 복원 기능 구현\n7. 내보내기 및 백업 UI 구현",
        "testStrategy": "1. 다양한 형식 내보내기 결과 검증\n2. 대용량 메모 내보내기 성능 테스트\n3. 백업 생성 및 복원 기능 테스트\n4. 자동 백업 스케줄링 테스트\n5. 다양한 메모 형식 및 콘텐츠 처리 테스트\n6. 오류 처리 및 예외 상황 테스트\n7. UI 인터랙션 및 사용자 경험 테스트",
        "priority": "low",
        "dependencies": [
          11,
          12,
          13,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "성능 최적화 및 배포 준비",
        "description": "애플리케이션 성능 최적화, 코드 리팩토링, 보안 강화, 모니터링 설정 및 배포 준비를 수행합니다.",
        "details": "1. 성능 최적화:\n   - 컴포넌트 메모이제이션 (React.memo, useMemo, useCallback)\n   - 이미지 최적화 (next/image 활용)\n   - 코드 스플리팅 및 지연 로딩\n   - API 응답 캐싱 (SWR 또는 React Query 활용)\n   - 데이터베이스 쿼리 최적화\n\n2. 보안 강화:\n   - CSRF 보호 구현\n   - XSS 방어 (DOMPurify 활용)\n   - 입력 데이터 검증 및 살균\n   - 레이트 리미팅 구현\n   - 보안 헤더 설정\n\n3. 모니터링 설정:\n   - Sentry 통합 구현:\n```typescript\n// app/sentry.ts\nimport * as Sentry from '@sentry/nextjs'\n\nSentry.init({\n  dsn: process.env.SENTRY_DSN,\n  tracesSampleRate: 1.0,\n  profilesSampleRate: 1.0,\n  environment: process.env.NODE_ENV,\n})\n```\n   - Vercel Analytics 설정\n   - 로깅 시스템 구현\n   - 성능 모니터링 설정\n\n4. 배포 준비:\n   - 환경 변수 설정 및 검증\n   - 빌드 스크립트 최적화\n   - CI/CD 파이프라인 구성 (GitHub Actions)\n   - Vercel 배포 설정\n   - Supabase 데이터베이스 마이그레이션 계획\n\n5. 코드 리팩토링:\n   - 중복 코드 제거\n   - 컴포넌트 구조 최적화\n   - 타입 정의 개선\n   - 에러 처리 일관성 확보\n\n6. 테스트 자동화:\n   - 단위 테스트 작성 (Jest + React Testing Library)\n   - API 통합 테스트 작성\n   - E2E 테스트 작성 (Playwright 또는 Cypress)\n   - 성능 테스트 자동화",
        "testStrategy": "1. 성능 측정 및 개선 효과 검증\n   - Lighthouse 점수 측정\n   - Core Web Vitals 모니터링\n   - 로딩 시간 및 인터랙션 지연 측정\n   - 메모리 사용량 분석\n\n2. 보안 취약점 테스트\n   - OWASP Top 10 취약점 점검\n   - 침투 테스트 수행\n   - 입력 검증 테스트\n   - 권한 검증 테스트\n\n3. 확장성 테스트\n   - 대량 데이터 처리 테스트\n   - 동시 사용자 부하 테스트\n   - 데이터베이스 성능 테스트\n\n4. 배포 프로세스 검증\n   - 다양한 환경에서의 배포 테스트\n   - 롤백 프로세스 테스트\n   - 마이그레이션 테스트",
        "priority": "high",
        "dependencies": [
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-28T04:58:29.491Z",
      "updated": "2025-07-28T07:11:24.764Z",
      "description": "Tasks for master context"
    }
  }
}